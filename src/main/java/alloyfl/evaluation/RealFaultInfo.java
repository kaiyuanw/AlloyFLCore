package alloyfl.evaluation;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import parser.etc.Names;
import parser.etc.Pair;

public enum RealFaultInfo {
  ADDR_FAULTY(
      "addrFaulty",
      ImmutableMap.of(
          "fact fact_1 {\n"
              + "(all b: (one Book) {\n"
              + "(all n: (one (b.entry)) {\n"
              + "(lone (n.(b.listed)))\n"
              + "})\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all b: (one Book) {\n"
              + "(all n: (one (b.entry)) {\n"
              + "(lone (n.(b.listed)))\n"
              + "})\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all b: (one Book) {\n"
              + "(all n: (one (b.entry)) {\n"
              + "(lone (n.(b.listed)))\n"
              + "})\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(all n: (one (b.entry)) {\n"
              + "(lone (n.(b.listed)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one (b.entry)) {\n"
              + "(lone (n.(b.listed)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(lone (n.(b.listed)))\n"
              + "}\n"
              + "|\n"
              + "(lone (n.(b.listed)))", 1)),
  ARRAY_1(
      "arr1",
      ImmutableMap.of(
          "fact InBound {\n"
              + "((all i: (one Int) {\n"
              + "((i >= 0) && (i < (Array.length)))\n"
              + "}) && ((Array.length) >= 0))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all i: (one Int) {\n"
              + "((i >= 0) && (i < (Array.length)))\n"
              + "}) && ((Array.length) >= 0))\n"
              + "}\n"
              + "|\n"
              + "((all i: (one Int) {\n"
              + "((i >= 0) && (i < (Array.length)))\n"
              + "}) && ((Array.length) >= 0))\n"
              + "|\n"
              + "(all i: (one Int) {\n"
              + "((i >= 0) && (i < (Array.length)))\n"
              + "})\n"
              + "|\n"
              + "i: (one Int)\n"
              + "|\n"
              + "(one Int)\n"
              + "|\n"
              + "Int", 1)),
  ARRAY_2(
      "arr2",
      ImmutableMap.of(
          "fact InBound {\n"
              + "((all i: (one ((Array.i2e).Element)) {\n"
              + "(i >= 0)\n"
              + "}) && (all i: (one ((Array.i2e).Element)) {\n"
              + "(i < (Array.length))\n"
              + "}) && ((Array.length) = (#Element)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all i: (one ((Array.i2e).Element)) {\n"
              + "(i >= 0)\n"
              + "}) && (all i: (one ((Array.i2e).Element)) {\n"
              + "(i < (Array.length))\n"
              + "}) && ((Array.length) = (#Element)))\n"
              + "}\n"
              + "|\n"
              + "((all i: (one ((Array.i2e).Element)) {\n"
              + "(i >= 0)\n"
              + "}) && (all i: (one ((Array.i2e).Element)) {\n"
              + "(i < (Array.length))\n"
              + "}) && ((Array.length) = (#Element)))\n"
              + "|\n"
              + "((Array.length) = (#Element))", 1,
          "fact InBound {\n"
              + "((all i: (one ((Array.i2e).Element)) {\n"
              + "(i >= 0)\n"
              + "}) && (all i: (one ((Array.i2e).Element)) {\n"
              + "(i < (Array.length))\n"
              + "}) && ((Array.length) = (#Element)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all i: (one ((Array.i2e).Element)) {\n"
              + "(i >= 0)\n"
              + "}) && (all i: (one ((Array.i2e).Element)) {\n"
              + "(i < (Array.length))\n"
              + "}) && ((Array.length) = (#Element)))\n"
              + "}\n"
              + "|\n"
              + "((all i: (one ((Array.i2e).Element)) {\n"
              + "(i >= 0)\n"
              + "}) && (all i: (one ((Array.i2e).Element)) {\n"
              + "(i < (Array.length))\n"
              + "}) && ((Array.length) = (#Element)))\n"
              + "|\n"
              + "((Array.length) = (#Element))\n"
              + "|\n"
              + "(#Element)", 1,
          "fact InBound {\n"
              + "((all i: (one ((Array.i2e).Element)) {\n"
              + "(i >= 0)\n"
              + "}) && (all i: (one ((Array.i2e).Element)) {\n"
              + "(i < (Array.length))\n"
              + "}) && ((Array.length) = (#Element)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all i: (one ((Array.i2e).Element)) {\n"
              + "(i >= 0)\n"
              + "}) && (all i: (one ((Array.i2e).Element)) {\n"
              + "(i < (Array.length))\n"
              + "}) && ((Array.length) = (#Element)))\n"
              + "}\n"
              + "|\n"
              + "((all i: (one ((Array.i2e).Element)) {\n"
              + "(i >= 0)\n"
              + "}) && (all i: (one ((Array.i2e).Element)) {\n"
              + "(i < (Array.length))\n"
              + "}) && ((Array.length) = (#Element)))\n"
              + "|\n"
              + "((Array.length) = (#Element))\n"
              + "|\n"
              + "(#Element)\n"
              + "|\n"
              + "Element", 1,
          "pred NoConflict[] {\n"
              + "(all i: (one ((Array.i2e).Element)) {\n"
              + "((#(i.(Array.i2e))) = 1)\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all i: (one ((Array.i2e).Element)) {\n"
              + "((#(i.(Array.i2e))) = 1)\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all i: (one ((Array.i2e).Element)) {\n"
              + "((#(i.(Array.i2e))) = 1)\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((#(i.(Array.i2e))) = 1)\n"
              + "}\n"
              + "|\n"
              + "((#(i.(Array.i2e))) = 1)", 2)),
  ARRAY_3(
      "arr3",
      ImmutableMap.of(
          "pred NoConflict[] {\n"
              + "(lone (Int.(Array.i2e)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(lone (Int.(Array.i2e)))\n"
              + "}\n"
              + "|\n"
              + "(lone (Int.(Array.i2e)))", 1,
          "pred NoConflict[] {\n"
              + "(lone (Int.(Array.i2e)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(lone (Int.(Array.i2e)))\n"
              + "}\n"
              + "|\n"
              + "(lone (Int.(Array.i2e)))\n"
              + "|\n"
              + "(Int.(Array.i2e))", 1,
          "pred NoConflict[] {\n"
              + "(lone (Int.(Array.i2e)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(lone (Int.(Array.i2e)))\n"
              + "}\n"
              + "|\n"
              + "(lone (Int.(Array.i2e)))\n"
              + "|\n"
              + "(Int.(Array.i2e))\n"
              + "|\n"
              + "Int", 1
      )
  ),
  ARRAY_4(
      "arr4",
      ImmutableMap.of(
          "fact InBound {\n"
              + "((all i: (one (Element.(~(Array.i2e)))) {\n"
              + "((i > 0) && (i < (Array.length)))\n"
              + "}) && ((Array.length) >= 0))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all i: (one (Element.(~(Array.i2e)))) {\n"
              + "((i > 0) && (i < (Array.length)))\n"
              + "}) && ((Array.length) >= 0))\n"
              + "}\n"
              + "|\n"
              + "((all i: (one (Element.(~(Array.i2e)))) {\n"
              + "((i > 0) && (i < (Array.length)))\n"
              + "}) && ((Array.length) >= 0))\n"
              + "|\n"
              + "(all i: (one (Element.(~(Array.i2e)))) {\n"
              + "((i > 0) && (i < (Array.length)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((i > 0) && (i < (Array.length)))\n"
              + "}\n"
              + "|\n"
              + "((i > 0) && (i < (Array.length)))\n"
              + "|\n"
              + "(i > 0)", 1
      )
  ),
  ARRAY_5(
      "arr5",
      ImmutableMap.of(
          "fact InBound {\n"
              + "((all a: (one Array),i: (one ((a.i2e).Element)) {\n"
              + "((i > 0) && (i < (a.length)))\n"
              + "}) && (all a: (one Array) {\n"
              + "((a.length) >= 0)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all a: (one Array),i: (one ((a.i2e).Element)) {\n"
              + "((i > 0) && (i < (a.length)))\n"
              + "}) && (all a: (one Array) {\n"
              + "((a.length) >= 0)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all a: (one Array),i: (one ((a.i2e).Element)) {\n"
              + "((i > 0) && (i < (a.length)))\n"
              + "}) && (all a: (one Array) {\n"
              + "((a.length) >= 0)\n"
              + "}))\n"
              + "|\n"
              + "(all a: (one Array),i: (one ((a.i2e).Element)) {\n"
              + "((i > 0) && (i < (a.length)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((i > 0) && (i < (a.length)))\n"
              + "}\n"
              + "|\n"
              + "((i > 0) && (i < (a.length)))\n"
              + "|\n"
              + "(i > 0)", 1
      )
  ),
  ARRAY_6(
      "arr6",
      ImmutableMap.of(
          "fact InBound {\n"
              + "(all x: (one Int) {\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all x: (one Int) {\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all x: (one Int) {\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "}\n"
              + "|\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "|\n"
              + "((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0))", 1,
          "fact InBound {\n"
              + "(all x: (one Int) {\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all x: (one Int) {\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all x: (one Int) {\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "}\n"
              + "|\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "|\n"
              + "((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0))\n"
              + "|\n"
              + "((Array.length) >= 0)", 1,
          "fact InBound {\n"
              + "(all x: (one Int) {\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all x: (one Int) {\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all x: (one Int) {\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "}\n"
              + "|\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "|\n"
              + "((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0))\n"
              + "|\n"
              + "((Array.length) >= 0)\n"
              + "|\n"
              + "(Array.length)", 1,
          "fact InBound {\n"
              + "(all x: (one Int) {\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all x: (one Int) {\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all x: (one Int) {\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "}\n"
              + "|\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "|\n"
              + "((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0))\n"
              + "|\n"
              + "((Array.length) >= 0)\n"
              + "|\n"
              + "(Array.length)\n"
              + "|\n"
              + "Array", 1,
          "fact InBound {\n"
              + "(all x: (one Int) {\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all x: (one Int) {\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all x: (one Int) {\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "}\n"
              + "|\n"
              + "(((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0)) || (no (x.(Array.i2e))))\n"
              + "|\n"
              + "((x >= 0) && (x < (Array.length)) && ((Array.length) >= 0))\n"
              + "|\n"
              + "((Array.length) >= 0)\n"
              + "|\n"
              + "(Array.length)\n"
              + "|\n"
              + "length", 1
      )
  ),
  ARRAY_7(
      "arr7",
      ImmutableMap.<String, Integer>builder().put(
          "fact InBound {\n"
              + "(((Array.length) = (#Element)) && (all i: (one Int),e: (one Element) {\n"
              + "(((i->e) in (Array.i2e)) => ((i >= 0) && (i < (Array.length))))\n"
              + "}) && ((Array.length) >= 0))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(((Array.length) = (#Element)) && (all i: (one Int),e: (one Element) {\n"
              + "(((i->e) in (Array.i2e)) => ((i >= 0) && (i < (Array.length))))\n"
              + "}) && ((Array.length) >= 0))\n"
              + "}\n"
              + "|\n"
              + "(((Array.length) = (#Element)) && (all i: (one Int),e: (one Element) {\n"
              + "(((i->e) in (Array.i2e)) => ((i >= 0) && (i < (Array.length))))\n"
              + "}) && ((Array.length) >= 0))", 1)
          .put(
              "fact InBound {\n"
                  + "(((Array.length) = (#Element)) && (all i: (one Int),e: (one Element) {\n"
                  + "(((i->e) in (Array.i2e)) => ((i >= 0) && (i < (Array.length))))\n"
                  + "}) && ((Array.length) >= 0))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(((Array.length) = (#Element)) && (all i: (one Int),e: (one Element) {\n"
                  + "(((i->e) in (Array.i2e)) => ((i >= 0) && (i < (Array.length))))\n"
                  + "}) && ((Array.length) >= 0))\n"
                  + "}\n"
                  + "|\n"
                  + "(((Array.length) = (#Element)) && (all i: (one Int),e: (one Element) {\n"
                  + "(((i->e) in (Array.i2e)) => ((i >= 0) && (i < (Array.length))))\n"
                  + "}) && ((Array.length) >= 0))\n"
                  + "|\n"
                  + "((Array.length) = (#Element))", 1)
          .put(
              "pred NoConflict[] {\n"
                  + "(lone (i2e.Element))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(lone (i2e.Element))\n"
                  + "}\n"
                  + "|\n"
                  + "(lone (i2e.Element))", 2)
          .put(
              "pred NoConflict[] {\n"
                  + "(lone (i2e.Element))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(lone (i2e.Element))\n"
                  + "}\n"
                  + "|\n"
                  + "(lone (i2e.Element))\n"
                  + "|\n"
                  + "(i2e.Element)", 2)
          .put(
              "pred NoConflict[] {\n"
                  + "(lone (i2e.Element))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(lone (i2e.Element))\n"
                  + "}\n"
                  + "|\n"
                  + "(lone (i2e.Element))\n"
                  + "|\n"
                  + "(i2e.Element)\n"
                  + "|\n"
                  + "i2e", 2)
          .put(
              "pred NoConflict[] {\n"
                  + "(lone (i2e.Element))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(lone (i2e.Element))\n"
                  + "}\n"
                  + "|\n"
                  + "(lone (i2e.Element))\n"
                  + "|\n"
                  + "(i2e.Element)\n"
                  + "|\n"
                  + "Element", 2).build()
  ),
  ARRAY_8(
      "arr8",
      ImmutableMap.of(
          "pred NoConflict[] {\n"
              + "((all idx: (one ((Array.i2e).Element)) {\n"
              + "(lone (idx.(Array.i2e)))\n"
              + "}) && (all idx1,idx2: (one ((Array.i2e).Element)) {\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all idx: (one ((Array.i2e).Element)) {\n"
              + "(lone (idx.(Array.i2e)))\n"
              + "}) && (all idx1,idx2: (one ((Array.i2e).Element)) {\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all idx: (one ((Array.i2e).Element)) {\n"
              + "(lone (idx.(Array.i2e)))\n"
              + "}) && (all idx1,idx2: (one ((Array.i2e).Element)) {\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "}))", 1,
          "pred NoConflict[] {\n"
              + "((all idx: (one ((Array.i2e).Element)) {\n"
              + "(lone (idx.(Array.i2e)))\n"
              + "}) && (all idx1,idx2: (one ((Array.i2e).Element)) {\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all idx: (one ((Array.i2e).Element)) {\n"
              + "(lone (idx.(Array.i2e)))\n"
              + "}) && (all idx1,idx2: (one ((Array.i2e).Element)) {\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all idx: (one ((Array.i2e).Element)) {\n"
              + "(lone (idx.(Array.i2e)))\n"
              + "}) && (all idx1,idx2: (one ((Array.i2e).Element)) {\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "}))\n"
              + "|\n"
              + "(all idx1,idx2: (one ((Array.i2e).Element)) {\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "})", 1,
          "pred NoConflict[] {\n"
              + "((all idx: (one ((Array.i2e).Element)) {\n"
              + "(lone (idx.(Array.i2e)))\n"
              + "}) && (all idx1,idx2: (one ((Array.i2e).Element)) {\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all idx: (one ((Array.i2e).Element)) {\n"
              + "(lone (idx.(Array.i2e)))\n"
              + "}) && (all idx1,idx2: (one ((Array.i2e).Element)) {\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all idx: (one ((Array.i2e).Element)) {\n"
              + "(lone (idx.(Array.i2e)))\n"
              + "}) && (all idx1,idx2: (one ((Array.i2e).Element)) {\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "}))\n"
              + "|\n"
              + "(all idx1,idx2: (one ((Array.i2e).Element)) {\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "}", 1,
          "pred NoConflict[] {\n"
              + "((all idx: (one ((Array.i2e).Element)) {\n"
              + "(lone (idx.(Array.i2e)))\n"
              + "}) && (all idx1,idx2: (one ((Array.i2e).Element)) {\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all idx: (one ((Array.i2e).Element)) {\n"
              + "(lone (idx.(Array.i2e)))\n"
              + "}) && (all idx1,idx2: (one ((Array.i2e).Element)) {\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all idx: (one ((Array.i2e).Element)) {\n"
              + "(lone (idx.(Array.i2e)))\n"
              + "}) && (all idx1,idx2: (one ((Array.i2e).Element)) {\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "}))\n"
              + "|\n"
              + "(all idx1,idx2: (one ((Array.i2e).Element)) {\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))\n"
              + "}\n"
              + "|\n"
              + "((idx1 != idx2) => ((idx1.(Array.i2e)) != (idx2.(Array.i2e))))", 1
      )
  ),
  ARRAY_9(
      "arr9",
      ImmutableMap.of(
          "fact InBound {\n"
              + "((all e: (one Element),i: (one Int) {\n"
              + "((((i->e) in (Array.i2e)) => ((i > 0) && (i < (Array.length)))) || (i = 0))\n"
              + "}) && (all size: (one (Array.length)) {\n"
              + "(size >= 0)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all e: (one Element),i: (one Int) {\n"
              + "((((i->e) in (Array.i2e)) => ((i > 0) && (i < (Array.length)))) || (i = 0))\n"
              + "}) && (all size: (one (Array.length)) {\n"
              + "(size >= 0)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all e: (one Element),i: (one Int) {\n"
              + "((((i->e) in (Array.i2e)) => ((i > 0) && (i < (Array.length)))) || (i = 0))\n"
              + "}) && (all size: (one (Array.length)) {\n"
              + "(size >= 0)\n"
              + "}))\n"
              + "|\n"
              + "(all e: (one Element),i: (one Int) {\n"
              + "((((i->e) in (Array.i2e)) => ((i > 0) && (i < (Array.length)))) || (i = 0))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((((i->e) in (Array.i2e)) => ((i > 0) && (i < (Array.length)))) || (i = 0))\n"
              + "}\n"
              + "|\n"
              + "((((i->e) in (Array.i2e)) => ((i > 0) && (i < (Array.length)))) || (i = 0))", 1,
          "fact InBound {\n"
              + "((all e: (one Element),i: (one Int) {\n"
              + "((((i->e) in (Array.i2e)) => ((i > 0) && (i < (Array.length)))) || (i = 0))\n"
              + "}) && (all size: (one (Array.length)) {\n"
              + "(size >= 0)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all e: (one Element),i: (one Int) {\n"
              + "((((i->e) in (Array.i2e)) => ((i > 0) && (i < (Array.length)))) || (i = 0))\n"
              + "}) && (all size: (one (Array.length)) {\n"
              + "(size >= 0)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all e: (one Element),i: (one Int) {\n"
              + "((((i->e) in (Array.i2e)) => ((i > 0) && (i < (Array.length)))) || (i = 0))\n"
              + "}) && (all size: (one (Array.length)) {\n"
              + "(size >= 0)\n"
              + "}))\n"
              + "|\n"
              + "(all e: (one Element),i: (one Int) {\n"
              + "((((i->e) in (Array.i2e)) => ((i > 0) && (i < (Array.length)))) || (i = 0))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((((i->e) in (Array.i2e)) => ((i > 0) && (i < (Array.length)))) || (i = 0))\n"
              + "}\n"
              + "|\n"
              + "((((i->e) in (Array.i2e)) => ((i > 0) && (i < (Array.length)))) || (i = 0))\n"
              + "|\n"
              + "(((i->e) in (Array.i2e)) => ((i > 0) && (i < (Array.length))))\n"
              + "|\n"
              + "((i > 0) && (i < (Array.length)))\n"
              + "|\n"
              + "(i > 0)", 1
      )
  ),
  ARRAY_10(
      "arr10",
      ImmutableMap.of(
          "pred NoConflict[] {\n"
              + "(all i: (one Int),e1,e2: (one Element) {\n"
              + "((((i->e1) in (Array.i2e)) && ((i->e2) in (Array.i2e))) => (e1 = e2))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all i: (one Int),e1,e2: (one Element) {\n"
              + "((((i->e1) in (Array.i2e)) && ((i->e2) in (Array.i2e))) => (e1 = e2))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all i: (one Int),e1,e2: (one Element) {\n"
              + "((((i->e1) in (Array.i2e)) && ((i->e2) in (Array.i2e))) => (e1 = e2))\n"
              + "})\n"
              + "|\n"
              + "i: (one Int)\n"
              + "|\n"
              + "(one Int)\n"
              + "|\n"
              + "Int", 1
      )
  ),
  ARRAY_11(
      "arr11",
      ImmutableMap.of(
          "fact InBound {\n"
              + "((all a: (one Array),m: (one Int),n: (one Element) {\n"
              + "(((m->n) in (a.i2e)) => ((m >= 0) && (m <= (Array.length))))\n"
              + "}) && ((Array.length) >= 0))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all a: (one Array),m: (one Int),n: (one Element) {\n"
              + "(((m->n) in (a.i2e)) => ((m >= 0) && (m <= (Array.length))))\n"
              + "}) && ((Array.length) >= 0))\n"
              + "}\n"
              + "|\n"
              + "((all a: (one Array),m: (one Int),n: (one Element) {\n"
              + "(((m->n) in (a.i2e)) => ((m >= 0) && (m <= (Array.length))))\n"
              + "}) && ((Array.length) >= 0))\n"
              + "|\n"
              + "(all a: (one Array),m: (one Int),n: (one Element) {\n"
              + "(((m->n) in (a.i2e)) => ((m >= 0) && (m <= (Array.length))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((m->n) in (a.i2e)) => ((m >= 0) && (m <= (Array.length))))\n"
              + "}\n"
              + "|\n"
              + "(((m->n) in (a.i2e)) => ((m >= 0) && (m <= (Array.length))))\n"
              + "|\n"
              + "((m >= 0) && (m <= (Array.length)))\n"
              + "|\n"
              + "(m <= (Array.length))", 1
      )
  ),
  BALANCED_BST_1(
      "balancedBST1",
      ImmutableMap.of(
          "fun Depth[n: Node] : (one Int) {\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "|\n"
              + "(n.(^(~(left + right))))\n"
              + "|\n"
              + "(^(~(left + right)))", 1)),
  BALANCED_BST_2(
      "balancedBST2",
      ImmutableMap.<String, Integer>builder().put(
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
              + "}\n"
              + "|\n"
              + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
              + "|\n"
              + "((some (n.left)) => (((n.left).elem) < (n.elem)))", 1)
          .put(
              "pred Sorted[] {\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "}\n"
                  + "|\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "|\n"
                  + "((some (n.left)) => (((n.left).elem) < (n.elem)))\n"
                  + "|\n"
                  + "(some (n.left))", 1)
          .put(
              "pred Sorted[] {\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "}\n"
                  + "|\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "|\n"
                  + "((some (n.left)) => (((n.left).elem) < (n.elem)))\n"
                  + "|\n"
                  + "(some (n.left))\n"
                  + "|\n"
                  + "(n.left)", 1)
          .put(
              "pred Sorted[] {\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "}\n"
                  + "|\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "|\n"
                  + "((some (n.left)) => (((n.left).elem) < (n.elem)))\n"
                  + "|\n"
                  + "(((n.left).elem) < (n.elem))\n"
                  + "|\n"
                  + "((n.left).elem)\n"
                  + "|\n"
                  + "(n.left)", 1)
          .put(
              "pred Sorted[] {\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "}\n"
                  + "|\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "|\n"
                  + "((some (n.right)) => (((n.right).elem) > (n.elem)))", 2)
          .put(
              "pred Sorted[] {\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "}\n"
                  + "|\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "|\n"
                  + "((some (n.right)) => (((n.right).elem) > (n.elem)))\n"
                  + "|\n"
                  + "(some (n.right))", 2)
          .put(
              "pred Sorted[] {\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "}\n"
                  + "|\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "|\n"
                  + "((some (n.right)) => (((n.right).elem) > (n.elem)))\n"
                  + "|\n"
                  + "(some (n.right))\n"
                  + "|\n"
                  + "(n.right)", 2)
          .put(
              "pred Sorted[] {\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "}\n"
                  + "|\n"
                  + "(((some (n.left)) => (((n.left).elem) < (n.elem))) && ((some (n.right)) => (((n.right).elem) > (n.elem))))\n"
                  + "|\n"
                  + "((some (n.right)) => (((n.right).elem) > (n.elem)))\n"
                  + "|\n"
                  + "(((n.right).elem) > (n.elem))\n"
                  + "|\n"
                  + "((n.right).elem)\n"
                  + "|\n"
                  + "(n.right)", 2)
          .put(
              "fun Depth[n: Node] : (one Int) {\n"
                  + "((#((BinaryTree.root).(*(left + right)))) - (#(n.(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((#((BinaryTree.root).(*(left + right)))) - (#(n.(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "((#((BinaryTree.root).(*(left + right)))) - (#(n.(left + right))))", 3)
          .put(
              "fun Depth[n: Node] : (one Int) {\n"
                  + "((#((BinaryTree.root).(*(left + right)))) - (#(n.(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((#((BinaryTree.root).(*(left + right)))) - (#(n.(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "((#((BinaryTree.root).(*(left + right)))) - (#(n.(left + right))))\n"
                  + "|\n"
                  + "(#((BinaryTree.root).(*(left + right))))", 3)
          .put(
              "fun Depth[n: Node] : (one Int) {\n"
                  + "((#((BinaryTree.root).(*(left + right)))) - (#(n.(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((#((BinaryTree.root).(*(left + right)))) - (#(n.(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "((#((BinaryTree.root).(*(left + right)))) - (#(n.(left + right))))\n"
                  + "|\n"
                  + "(#((BinaryTree.root).(*(left + right))))\n"
                  + "|\n"
                  + "((BinaryTree.root).(*(left + right)))", 3)
          .put(
              "fun Depth[n: Node] : (one Int) {\n"
                  + "((#((BinaryTree.root).(*(left + right)))) - (#(n.(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((#((BinaryTree.root).(*(left + right)))) - (#(n.(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "((#((BinaryTree.root).(*(left + right)))) - (#(n.(left + right))))\n"
                  + "|\n"
                  + "(#((BinaryTree.root).(*(left + right))))\n"
                  + "|\n"
                  + "((BinaryTree.root).(*(left + right)))\n"
                  + "|\n"
                  + "(*(left + right))", 3)
          .put(
              "fun Depth[n: Node] : (one Int) {\n"
                  + "((#((BinaryTree.root).(*(left + right)))) - (#(n.(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((#((BinaryTree.root).(*(left + right)))) - (#(n.(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "((#((BinaryTree.root).(*(left + right)))) - (#(n.(left + right))))\n"
                  + "|\n"
                  + "(#(n.(left + right)))\n"
                  + "|\n"
                  + "(n.(left + right))\n"
                  + "|\n"
                  + "(left + right)", 3)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "}\n"
                  + "|\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))", 4)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "}\n"
                  + "|\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "|\n"
                  + "((#(n1.(left + right))) - (#(n2.(left + right))))", 4)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "}\n"
                  + "|\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "|\n"
                  + "((#(n1.(left + right))) - (#(n2.(left + right))))\n"
                  + "|\n"
                  + "(#(n1.(left + right)))", 4)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "}\n"
                  + "|\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "|\n"
                  + "((#(n1.(left + right))) - (#(n2.(left + right))))\n"
                  + "|\n"
                  + "(#(n1.(left + right)))\n"
                  + "|\n"
                  + "(n1.(left + right))", 4)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "}\n"
                  + "|\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "|\n"
                  + "((#(n1.(left + right))) - (#(n2.(left + right))))\n"
                  + "|\n"
                  + "(#(n2.(left + right)))", 4)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "}\n"
                  + "|\n"
                  + "(lone ((#(n1.(left + right))) - (#(n2.(left + right)))))\n"
                  + "|\n"
                  + "((#(n1.(left + right))) - (#(n2.(left + right))))\n"
                  + "|\n"
                  + "(#(n2.(left + right)))\n"
                  + "|\n"
                  + "(n2.(left + right))", 4).build()),
  BALANCED_BST_3(
      "balancedBST3",
      ImmutableMap.of(
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "|\n"
              + "(all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "})\n"
              + "|\n"
              + "n2: (one (n.(^left)))\n"
              + "|\n"
              + "(one (n.(^left)))\n"
              + "|\n"
              + "(n.(^left))\n"
              + "|\n"
              + "(^left)", 1,
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "|\n"
              + "(all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "})\n"
              + "|\n"
              + "n2: (one (n.(^left)))\n"
              + "|\n"
              + "(one (n.(^left)))\n"
              + "|\n"
              + "(n.(^left))\n"
              + "|\n"
              + "(^left)\n"
              + "|\n"
              + "left", 1,
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "|\n"
              + "(all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "})\n"
              + "|\n"
              + "n2: (one (n.(^right)))\n"
              + "|\n"
              + "(one (n.(^right)))\n"
              + "|\n"
              + "(n.(^right))\n"
              + "|\n"
              + "(^right)", 2,
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all n2: (one (n.(^left))) {\n"
              + "((n2.elem) < (n.elem))\n"
              + "}) && (all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "}))\n"
              + "|\n"
              + "(all n2: (one (n.(^right))) {\n"
              + "((n2.elem) > (n.elem))\n"
              + "})\n"
              + "|\n"
              + "n2: (one (n.(^right)))\n"
              + "|\n"
              + "(one (n.(^right)))\n"
              + "|\n"
              + "(n.(^right))\n"
              + "|\n"
              + "(^right)\n"
              + "|\n"
              + "right", 2,
          "pred Balanced[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) <=> ((integer/mul[(integer/signum[(integer/minus[(Depth[n1]),(Depth[n2])])]),(integer/minus[(Depth[n1]),(Depth[n2])])]) <= 1))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) <=> ((integer/mul[(integer/signum[(integer/minus[(Depth[n1]),(Depth[n2])])]),(integer/minus[(Depth[n1]),(Depth[n2])])]) <= 1))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) <=> ((integer/mul[(integer/signum[(integer/minus[(Depth[n1]),(Depth[n2])])]),(integer/minus[(Depth[n1]),(Depth[n2])])]) <= 1))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) <=> ((integer/mul[(integer/signum[(integer/minus[(Depth[n1]),(Depth[n2])])]),(integer/minus[(Depth[n1]),(Depth[n2])])]) <= 1))\n"
              + "}\n"
              + "|\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) <=> ((integer/mul[(integer/signum[(integer/minus[(Depth[n1]),(Depth[n2])])]),(integer/minus[(Depth[n1]),(Depth[n2])])]) <= 1))",
          3)),
  BALANCED_BST_4(
      "balancedBST4",
      ImmutableMap.of(
          "pred HasAtMostOneChild[n: Node] {\n"
              + "\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "\n"
              + "}", 1,
          "pred HasAtMostOneChild[n: Node] {\n"
              + "\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "\n"
              + "}\n"
              + "|\n"
              + "", 1,
          "fun Depth[n: Node] : (one Int) {\n"
              + "0\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "0\n"
              + "}\n"
              + "|\n"
              + "0", 2,
          "pred Balanced[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "}\n"
              + "|\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "|\n"
              + "((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1))\n"
              + "|\n"
              + "(((Depth[n1]) - (Depth[n2])) >= -1)\n"
              + "|\n"
              + "((Depth[n1]) - (Depth[n2]))", 3,
          "pred Balanced[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "}\n"
              + "|\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "|\n"
              + "((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1))\n"
              + "|\n"
              + "(((Depth[n1]) - (Depth[n2])) <= 1)\n"
              + "|\n"
              + "((Depth[n1]) - (Depth[n2]))", 3
      )
  ),
  BALANCED_BST_5(
      "balancedBST5",
      ImmutableMap.of(
          "fun Depth[n: Node] : (one Int) {\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "|\n"
              + "(n.(^(~(left + right))))\n"
              + "|\n"
              + "(^(~(left + right)))", 1
      )
  ),
  BALANCED_BST_6(
      "balancedBST6",
      ImmutableMap.of(
          "pred Balanced[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) < 2) && (((Depth[n1]) - (Depth[n2])) > -2)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) < 2) && (((Depth[n1]) - (Depth[n2])) > -2)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) < 2) && (((Depth[n1]) - (Depth[n2])) > -2)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) < 2) && (((Depth[n1]) - (Depth[n2])) > -2)))\n"
              + "}\n"
              + "|\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) < 2) && (((Depth[n1]) - (Depth[n2])) > -2)))\n"
              + "|\n"
              + "((((Depth[n1]) - (Depth[n2])) < 2) && (((Depth[n1]) - (Depth[n2])) > -2))\n"
              + "|\n"
              + "(((Depth[n1]) - (Depth[n2])) < 2)\n"
              + "|\n"
              + "((Depth[n1]) - (Depth[n2]))", 1,
          "pred Balanced[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) < 2) && (((Depth[n1]) - (Depth[n2])) > -2)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) < 2) && (((Depth[n1]) - (Depth[n2])) > -2)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) < 2) && (((Depth[n1]) - (Depth[n2])) > -2)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) < 2) && (((Depth[n1]) - (Depth[n2])) > -2)))\n"
              + "}\n"
              + "|\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) < 2) && (((Depth[n1]) - (Depth[n2])) > -2)))\n"
              + "|\n"
              + "((((Depth[n1]) - (Depth[n2])) < 2) && (((Depth[n1]) - (Depth[n2])) > -2))\n"
              + "|\n"
              + "(((Depth[n1]) - (Depth[n2])) > -2)\n"
              + "|\n"
              + "((Depth[n1]) - (Depth[n2]))", 1
      )
  ),
  BALANCED_BST_7(
      "balancedBST7",
      ImmutableMap.of(
          "fun Depth[n: Node] : (one Int) {\n"
              + "(#(n.(~(^(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(#(n.(~(^(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "(#(n.(~(^(left + right)))))\n"
              + "|\n"
              + "(n.(~(^(left + right))))\n"
              + "|\n"
              + "(~(^(left + right)))\n"
              + "|\n"
              + "(^(left + right))", 1
      )
  ),
  BALANCED_BST_8(
      "balancedBST8",
      ImmutableMap.of(
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "|\n"
              + "(all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "})\n"
              + "|\n"
              + "x: (one ((n.left).elem))\n"
              + "|\n"
              + "(one ((n.left).elem))\n"
              + "|\n"
              + "((n.left).elem)", 1,
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "|\n"
              + "(all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "})\n"
              + "|\n"
              + "x: (one ((n.left).elem))\n"
              + "|\n"
              + "(one ((n.left).elem))\n"
              + "|\n"
              + "((n.left).elem)\n"
              + "|\n"
              + "(n.left)", 1,
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "|\n"
              + "(all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "})\n"
              + "|\n"
              + "x: (one ((n.right).elem))\n"
              + "|\n"
              + "(one ((n.right).elem))\n"
              + "|\n"
              + "((n.right).elem)", 2,
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all x: (one ((n.left).elem)) {\n"
              + "(x < (n.elem))\n"
              + "}) && (all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "}))\n"
              + "|\n"
              + "(all x: (one ((n.right).elem)) {\n"
              + "(x > (n.elem))\n"
              + "})\n"
              + "|\n"
              + "x: (one ((n.right).elem))\n"
              + "|\n"
              + "(one ((n.right).elem))\n"
              + "|\n"
              + "((n.right).elem)\n"
              + "|\n"
              + "(n.right)", 2,
          "fun Depth[n: Node] : (one Int) {\n"
              + "(#(n.(~(^(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(#(n.(~(^(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "(#(n.(~(^(left + right)))))\n"
              + "|\n"
              + "(n.(~(^(left + right))))\n"
              + "|\n"
              + "(~(^(left + right)))\n"
              + "|\n"
              + "(^(left + right))", 3
      )
  ),
  BALANCED_BST_9(
      "balancedBST9",
      ImmutableMap.of(
          "fun Depth[n: Node] : (one Int) {\n"
              + "(#(n.(~(^(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(#(n.(~(^(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "(#(n.(~(^(left + right)))))\n"
              + "|\n"
              + "(n.(~(^(left + right))))\n"
              + "|\n"
              + "(~(^(left + right)))\n"
              + "|\n"
              + "(^(left + right))", 1
      )
  ),
  BALANCED_BST_10(
      "balancedBST10",
      ImmutableMap.<String, Integer>builder().put(
          "fact Acyclic {\n"
              + "(all n: (one Node) {\n"
              + "(((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right))) <=> ((#(n.(left + right))) > 0))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "(((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right))) <=> ((#(n.(left + right))) > 0))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "(((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right))) <=> ((#(n.(left + right))) > 0))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right))) <=> ((#(n.(left + right))) > 0))\n"
              + "}\n"
              + "|\n"
              + "(((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right))) <=> ((#(n.(left + right))) > 0))\n"
              + "|\n"
              + "((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right)))\n"
              + "|\n"
              + "(((#(~left)) + (#(~right))) <= 1)\n"
              + "|\n"
              + "((#(~left)) + (#(~right)))", 1)
          .put(
              "fact Acyclic {\n"
                  + "(all n: (one Node) {\n"
                  + "(((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right))) <=> ((#(n.(left + right))) > 0))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "(((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right))) <=> ((#(n.(left + right))) > 0))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right))) <=> ((#(n.(left + right))) > 0))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right))) <=> ((#(n.(left + right))) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "(((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right))) <=> ((#(n.(left + right))) > 0))",
              2)
          .put(
              "fact Acyclic {\n"
                  + "(all n: (one Node) {\n"
                  + "(((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right))) <=> ((#(n.(left + right))) > 0))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "(((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right))) <=> ((#(n.(left + right))) > 0))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right))) <=> ((#(n.(left + right))) > 0))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right))) <=> ((#(n.(left + right))) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "(((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right))) <=> ((#(n.(left + right))) > 0))\n"
                  + "|\n"
                  + "((n !in (n.(^(left + right)))) && (((#(~left)) + (#(~right))) <= 1) && ((n.left) != (n.right)))",
              2)
          .put(
              "fun Depth[n: Node] : (one Int) {\n"
                  + "(#(n.(^(~(left + right)))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(#(n.(^(~(left + right)))))\n"
                  + "}\n"
                  + "|\n"
                  + "(#(n.(^(~(left + right)))))\n"
                  + "|\n"
                  + "(n.(^(~(left + right))))\n"
                  + "|\n"
                  + "(^(~(left + right)))", 3)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "}\n"
                  + "|\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "|\n"
                  + "(((Depth[n1]) - (Depth[n2])) <= 1)\n"
                  + "|\n"
                  + "((Depth[n1]) - (Depth[n2]))", 4)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "}\n"
                  + "|\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "|\n"
                  + "(((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2]))))",
              4)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "}\n"
                  + "|\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "|\n"
                  + "(((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2]))))\n"
                  + "|\n"
                  + "((#((Depth[n1]) - (Depth[n2]))) = 0)", 4)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "}\n"
                  + "|\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "|\n"
                  + "(((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2]))))\n"
                  + "|\n"
                  + "((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))",
              4)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "}\n"
                  + "|\n"
                  + "((((Depth[n1]) - (Depth[n2])) <= 1) || (((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))))\n"
                  + "|\n"
                  + "(((#((Depth[n1]) - (Depth[n2]))) = 0) <=> ((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2]))))\n"
                  + "|\n"
                  + "((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2]) && ((Depth[n1]) >= (Depth[n2])))\n"
                  + "|\n"
                  + "((Depth[n1]) >= (Depth[n2]))", 4
          ).build()
  ),
  BALANCED_BST_11(
      "balancedBST11",
      ImmutableMap.of(
          "pred HasAtMostOneChild[n: Node] {\n"
              + "\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "\n"
              + "}", 1,
          "pred HasAtMostOneChild[n: Node] {\n"
              + "\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "\n"
              + "}\n"
              + "|\n"
              + "", 1,
          "fun Depth[n: Node] : (one Int) {\n"
              + "0\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "0\n"
              + "}\n"
              + "|\n"
              + "0", 2
      )
  ),
  BALANCED_BST_12(
      "balancedBST12",
      ImmutableMap.<String, Integer>builder().put(
          "pred HasAtMostOneChild[n: Node] {\n"
              + "(all n: (one Node) {\n"
              + "(lone ((n.left) + (n.right)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "(lone ((n.left) + (n.right)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "(lone ((n.left) + (n.right)))\n"
              + "})", 1)
          .put(
              "pred HasAtMostOneChild[n: Node] {\n"
                  + "(all n: (one Node) {\n"
                  + "(lone ((n.left) + (n.right)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "(lone ((n.left) + (n.right)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(lone ((n.left) + (n.right)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(lone ((n.left) + (n.right)))\n"
                  + "}", 1)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "}\n"
                  + "|\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))",
              2)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "}\n"
                  + "|\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "|\n"
                  + "((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1))",
              2)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "}\n"
                  + "|\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "|\n"
                  + "((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1))\n"
                  + "|\n"
                  + "(#((n1.left).(^(left + right))))", 2)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "}\n"
                  + "|\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "|\n"
                  + "((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1))\n"
                  + "|\n"
                  + "((#((n1.right).(^(left + right)))) + 1)", 2)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "}\n"
                  + "|\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "|\n"
                  + "((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1))\n"
                  + "|\n"
                  + "((#((n1.right).(^(left + right)))) + 1)\n"
                  + "|\n"
                  + "(#((n1.right).(^(left + right))))", 2)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "}\n"
                  + "|\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "|\n"
                  + "((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1))",
              2)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "}\n"
                  + "|\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "|\n"
                  + "((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1))\n"
                  + "|\n"
                  + "(#((n2.right).(^(left + right))))", 2)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "}\n"
                  + "|\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "|\n"
                  + "((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1))\n"
                  + "|\n"
                  + "((#((n2.left).(^(left + right)))) + 1)", 2)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "}\n"
                  + "|\n"
                  + "(((#((n1.left).(^(left + right)))) <= ((#((n1.right).(^(left + right)))) + 1)) && ((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1)))\n"
                  + "|\n"
                  + "((#((n2.right).(^(left + right)))) <= ((#((n2.left).(^(left + right)))) + 1))\n"
                  + "|\n"
                  + "((#((n2.left).(^(left + right)))) + 1)\n"
                  + "|\n"
                  + "(#((n2.left).(^(left + right))))", 2
          ).build()
  ),
  BALANCED_BST_13(
      "balancedBST13",
      ImmutableMap.of(
          "fun Depth[n: Node] : (one Int) {\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "|\n"
              + "(n.(^(~(left + right))))\n"
              + "|\n"
              + "(^(~(left + right)))", 1
      )
  ),
  BALANCED_BST_14(
      "balancedBST14",
      ImmutableMap.of(
          "fun Depth[n: Node] : (one Int) {\n"
              + "(#(n.(~(^(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(#(n.(~(^(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "(#(n.(~(^(left + right)))))\n"
              + "|\n"
              + "(n.(~(^(left + right))))\n"
              + "|\n"
              + "(~(^(left + right)))\n"
              + "|\n"
              + "(^(left + right))", 1
      )
  ),
  BALANCED_BST_15(
      "balancedBST15",
      ImmutableMap.of(
          "fun Depth[n: Node] : (one Int) {\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "|\n"
              + "(n.(^(~(left + right))))\n"
              + "|\n"
              + "(^(~(left + right)))", 1
      )
  ),
  BALANCED_BST_16(
      "balancedBST16",
      ImmutableMap.of(
          "pred Balanced[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) = (Depth[n2])) || (((Depth[n1]) - 1) = (Depth[n2])) || (((Depth[n1]) + 1) = (Depth[n2])))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) = (Depth[n2])) || (((Depth[n1]) - 1) = (Depth[n2])) || (((Depth[n1]) + 1) = (Depth[n2])))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) = (Depth[n2])) || (((Depth[n1]) - 1) = (Depth[n2])) || (((Depth[n1]) + 1) = (Depth[n2])))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n1 = n2) || (((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) = (Depth[n2])) || (((Depth[n1]) - 1) = (Depth[n2])) || (((Depth[n1]) + 1) = (Depth[n2])))))\n"
              + "}\n"
              + "|\n"
              + "((n1 = n2) || (((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) = (Depth[n2])) || (((Depth[n1]) - 1) = (Depth[n2])) || (((Depth[n1]) + 1) = (Depth[n2])))))\n"
              + "|\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) = (Depth[n2])) || (((Depth[n1]) - 1) = (Depth[n2])) || (((Depth[n1]) + 1) = (Depth[n2]))))\n"
              + "|\n"
              + "(((Depth[n1]) = (Depth[n2])) || (((Depth[n1]) - 1) = (Depth[n2])) || (((Depth[n1]) + 1) = (Depth[n2])))\n"
              + "|\n"
              + "(((Depth[n1]) - 1) = (Depth[n2]))\n"
              + "|\n"
              + "((Depth[n1]) - 1)", 1,
          "pred Balanced[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) = (Depth[n2])) || (((Depth[n1]) - 1) = (Depth[n2])) || (((Depth[n1]) + 1) = (Depth[n2])))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) = (Depth[n2])) || (((Depth[n1]) - 1) = (Depth[n2])) || (((Depth[n1]) + 1) = (Depth[n2])))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) = (Depth[n2])) || (((Depth[n1]) - 1) = (Depth[n2])) || (((Depth[n1]) + 1) = (Depth[n2])))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n1 = n2) || (((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) = (Depth[n2])) || (((Depth[n1]) - 1) = (Depth[n2])) || (((Depth[n1]) + 1) = (Depth[n2])))))\n"
              + "}\n"
              + "|\n"
              + "((n1 = n2) || (((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) = (Depth[n2])) || (((Depth[n1]) - 1) = (Depth[n2])) || (((Depth[n1]) + 1) = (Depth[n2])))))\n"
              + "|\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) = (Depth[n2])) || (((Depth[n1]) - 1) = (Depth[n2])) || (((Depth[n1]) + 1) = (Depth[n2]))))\n"
              + "|\n"
              + "(((Depth[n1]) = (Depth[n2])) || (((Depth[n1]) - 1) = (Depth[n2])) || (((Depth[n1]) + 1) = (Depth[n2])))\n"
              + "|\n"
              + "(((Depth[n1]) + 1) = (Depth[n2]))\n"
              + "|\n"
              + "((Depth[n1]) + 1)", 1
      )
  ),
  BALANCED_BST_17(
      "balancedBST17",
      ImmutableMap.of(
          "pred HasAtMostOneChild[n: Node] {\n"
              + "((#(n.(^(left + right)))) <= 1)\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((#(n.(^(left + right)))) <= 1)\n"
              + "}\n"
              + "|\n"
              + "((#(n.(^(left + right)))) <= 1)\n"
              + "|\n"
              + "(#(n.(^(left + right))))\n"
              + "|\n"
              + "(n.(^(left + right)))\n"
              + "|\n"
              + "(^(left + right))", 1,
          "fun Depth[n: Node] : (one Int) {\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "|\n"
              + "(n.(^(~(left + right))))\n"
              + "|\n"
              + "(^(~(left + right)))", 2,
          "pred Balanced[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) <= 1))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) <= 1))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) <= 1))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) <= 1))\n"
              + "}\n"
              + "|\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) <= 1))\n"
              + "|\n"
              + "(((Depth[n1]) - (Depth[n2])) <= 1)\n"
              + "|\n"
              + "((Depth[n1]) - (Depth[n2]))", 3
      )
  ),
  BALANCED_BST_18(
      "balancedBST18",
      ImmutableMap.of(
          "fact Acyclic {\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^(left + right)))) && (all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}) && (no child: (one Node) {\n"
              + "((child in (n.left)) && (child in (n.right)))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^(left + right)))) && (all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}) && (no child: (one Node) {\n"
              + "((child in (n.left)) && (child in (n.right)))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^(left + right)))) && (all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}) && (no child: (one Node) {\n"
              + "((child in (n.left)) && (child in (n.right)))\n"
              + "}))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n !in (n.(^(left + right)))) && (all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}) && (no child: (one Node) {\n"
              + "((child in (n.left)) && (child in (n.right)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((n !in (n.(^(left + right)))) && (all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}) && (no child: (one Node) {\n"
              + "((child in (n.left)) && (child in (n.right)))\n"
              + "}))\n"
              + "|\n"
              + "(all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}\n"
              + "|\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "|\n"
              + "((n = (p0.(left + right))) && (p0 != p1))\n"
              + "|\n"
              + "(n = (p0.(left + right)))", 1,
          "fact Acyclic {\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^(left + right)))) && (all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}) && (no child: (one Node) {\n"
              + "((child in (n.left)) && (child in (n.right)))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^(left + right)))) && (all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}) && (no child: (one Node) {\n"
              + "((child in (n.left)) && (child in (n.right)))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^(left + right)))) && (all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}) && (no child: (one Node) {\n"
              + "((child in (n.left)) && (child in (n.right)))\n"
              + "}))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n !in (n.(^(left + right)))) && (all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}) && (no child: (one Node) {\n"
              + "((child in (n.left)) && (child in (n.right)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((n !in (n.(^(left + right)))) && (all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}) && (no child: (one Node) {\n"
              + "((child in (n.left)) && (child in (n.right)))\n"
              + "}))\n"
              + "|\n"
              + "(all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}\n"
              + "|\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "|\n"
              + "((n != (p1.left)) && (n != (p1.right)))\n"
              + "|\n"
              + "(n != (p1.left))", 1,
          "fact Acyclic {\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^(left + right)))) && (all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}) && (no child: (one Node) {\n"
              + "((child in (n.left)) && (child in (n.right)))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^(left + right)))) && (all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}) && (no child: (one Node) {\n"
              + "((child in (n.left)) && (child in (n.right)))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^(left + right)))) && (all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}) && (no child: (one Node) {\n"
              + "((child in (n.left)) && (child in (n.right)))\n"
              + "}))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n !in (n.(^(left + right)))) && (all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}) && (no child: (one Node) {\n"
              + "((child in (n.left)) && (child in (n.right)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((n !in (n.(^(left + right)))) && (all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}) && (no child: (one Node) {\n"
              + "((child in (n.left)) && (child in (n.right)))\n"
              + "}))\n"
              + "|\n"
              + "(all p0: (one Node),p1: (one Node) {\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "}\n"
              + "|\n"
              + "(((n = (p0.(left + right))) && (p0 != p1)) => ((n != (p1.left)) && (n != (p1.right))))\n"
              + "|\n"
              + "((n != (p1.left)) && (n != (p1.right)))\n"
              + "|\n"
              + "(n != (p1.right))", 1,
          "fun Depth[n: Node] : (one Int) {\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "(#(n.(^(~(left + right)))))\n"
              + "|\n"
              + "(n.(^(~(left + right))))\n"
              + "|\n"
              + "(^(~(left + right)))", 2
      )
  ),
  BALANCED_BST_19(
      "balancedBST19",
      ImmutableMap.<String, Integer>builder().put(
          "pred HasAtMostOneChild[n: Node] {\n"
              + "(lone (n.(^(left + right))))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(lone (n.(^(left + right))))\n"
              + "}\n"
              + "|\n"
              + "(lone (n.(^(left + right))))\n"
              + "|\n"
              + "(n.(^(left + right)))\n"
              + "|\n"
              + "(^(left + right))", 1)
          .put(
              "fun Depth[n: Node] : (one Int) {\n"
                  + "(#((root.n).(*(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(#((root.n).(*(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "(#((root.n).(*(left + right))))\n"
                  + "|\n"
                  + "((root.n).(*(left + right)))\n"
                  + "|\n"
                  + "(root.n)", 2)
          .put(
              "fun Depth[n: Node] : (one Int) {\n"
                  + "(#((root.n).(*(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(#((root.n).(*(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "(#((root.n).(*(left + right))))\n"
                  + "|\n"
                  + "((root.n).(*(left + right)))\n"
                  + "|\n"
                  + "(root.n)\n"
                  + "|\n"
                  + "root", 2)
          .put(
              "fun Depth[n: Node] : (one Int) {\n"
                  + "(#((root.n).(*(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(#((root.n).(*(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "(#((root.n).(*(left + right))))\n"
                  + "|\n"
                  + "((root.n).(*(left + right)))\n"
                  + "|\n"
                  + "(*(left + right))", 2)
          .put(
              "fun Depth[n: Node] : (one Int) {\n"
                  + "(#((root.n).(*(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(#((root.n).(*(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "(#((root.n).(*(left + right))))\n"
                  + "|\n"
                  + "((root.n).(*(left + right)))\n"
                  + "|\n"
                  + "(*(left + right))\n"
                  + "|\n"
                  + "(left + right)", 2)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "}\n"
                  + "|\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))", 3)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "}\n"
                  + "|\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "|\n"
                  + "(#(n1.(^(left + right))))\n"
                  + "|\n"
                  + "(n1.(^(left + right)))", 3)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "}\n"
                  + "|\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "|\n"
                  + "(#(n1.(^(left + right))))\n"
                  + "|\n"
                  + "(n1.(^(left + right)))\n"
                  + "|\n"
                  + "(^(left + right))", 3)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "}\n"
                  + "|\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "|\n"
                  + "((#(n2.(^(left + right)))) + 1)", 3)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "}\n"
                  + "|\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "|\n"
                  + "((#(n2.(^(left + right)))) + 1)\n"
                  + "|\n"
                  + "(#(n2.(^(left + right))))\n"
                  + "|\n"
                  + "(n2.(^(left + right)))", 3)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "}\n"
                  + "|\n"
                  + "((#(n1.(^(left + right)))) <= ((#(n2.(^(left + right)))) + 1))\n"
                  + "|\n"
                  + "((#(n2.(^(left + right)))) + 1)\n"
                  + "|\n"
                  + "(#(n2.(^(left + right))))\n"
                  + "|\n"
                  + "(n2.(^(left + right)))\n"
                  + "|\n"
                  + "(^(left + right))", 3
          ).build()
  ),
  BALANCED_BST_20(
      "balancedBST20",
      ImmutableMap.of(
          "fun Depth[n: Node] : (one Int) {\n"
              + "(#(n.(~(^(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(#(n.(~(^(left + right)))))\n"
              + "}\n"
              + "|\n"
              + "(#(n.(~(^(left + right)))))\n"
              + "|\n"
              + "(n.(~(^(left + right))))\n"
              + "|\n"
              + "(~(^(left + right)))\n"
              + "|\n"
              + "(^(left + right))", 1,
          "pred Balanced[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "}\n"
              + "|\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "|\n"
              + "((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1))\n"
              + "|\n"
              + "(((Depth[n1]) - (Depth[n2])) >= -1)\n"
              + "|\n"
              + "((Depth[n1]) - (Depth[n2]))", 2,
          "pred Balanced[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "}\n"
              + "|\n"
              + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => ((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1)))\n"
              + "|\n"
              + "((((Depth[n1]) - (Depth[n2])) >= -1) && (((Depth[n1]) - (Depth[n2])) <= 1))\n"
              + "|\n"
              + "(((Depth[n1]) - (Depth[n2])) <= 1)\n"
              + "|\n"
              + "((Depth[n1]) - (Depth[n2]))", 2
      )
  ),
  BALANCED_BST_21(
      "balancedBST21",
      ImmutableMap.of(
          "fun Depth[n: Node] : (one Int) {\n"
              + "(#({ n1: (one Node) {\n"
              + "(n in (n1.(^(left + right))))\n"
              + "} }))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(#({ n1: (one Node) {\n"
              + "(n in (n1.(^(left + right))))\n"
              + "} }))\n"
              + "}\n"
              + "|\n"
              + "(#({ n1: (one Node) {\n"
              + "(n in (n1.(^(left + right))))\n"
              + "} }))\n"
              + "|\n"
              + "({ n1: (one Node) {\n"
              + "(n in (n1.(^(left + right))))\n"
              + "} })\n"
              + "|\n"
              + "{\n"
              + "(n in (n1.(^(left + right))))\n"
              + "}\n"
              + "|\n"
              + "(n in (n1.(^(left + right))))\n"
              + "|\n"
              + "(n1.(^(left + right)))\n"
              + "|\n"
              + "(^(left + right))", 1
      )
  ),
  BALANCED_BST_22(
      "balancedBST22",
      ImmutableMap.<String, Integer>builder().put(
          "fact Acyclic {\n"
              + "(all n: (one Node) {\n"
              + "((all bt: (one BinaryTree) {\n"
              + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
              + "}) && (all n2,n3: (one Node) {\n"
              + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
              + "}) && (all n2: (one Node) {\n"
              + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((all bt: (one BinaryTree) {\n"
              + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
              + "}) && (all n2,n3: (one Node) {\n"
              + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
              + "}) && (all n2: (one Node) {\n"
              + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
              + "}))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((all bt: (one BinaryTree) {\n"
              + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
              + "}) && (all n2,n3: (one Node) {\n"
              + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
              + "}) && (all n2: (one Node) {\n"
              + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
              + "}))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((all bt: (one BinaryTree) {\n"
              + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
              + "}) && (all n2,n3: (one Node) {\n"
              + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
              + "}) && (all n2: (one Node) {\n"
              + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all bt: (one BinaryTree) {\n"
              + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
              + "}) && (all n2,n3: (one Node) {\n"
              + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
              + "}) && (all n2: (one Node) {\n"
              + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
              + "}))\n"
              + "|\n"
              + "(all n2,n3: (one Node) {\n"
              + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
              + "})", 1)
          .put(
              "fact Acyclic {\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}", 1)
          .put(
              "fact Acyclic {\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))", 1)
          .put(
              "fact Acyclic {\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "|\n"
                  + "(n3 in (n2.(left + right)))", 1)
          .put(
              "fact Acyclic {\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}\n"
                  + "|\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "|\n"
                  + "(n3 !in (n.(left + right)))", 1)
          .put(
              "fact Acyclic {\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}\n"
                  + "|\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))",
              2)
          .put(
              "fact Acyclic {\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}\n"
                  + "|\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "|\n"
                  + "(((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left)))", 2)
          .put(
              "fact Acyclic {\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all bt: (one BinaryTree) {\n"
                  + "((n in ((bt.root).(*(left + right)))) => (n !in (n.(^(left + right)))))\n"
                  + "}) && (all n2,n3: (one Node) {\n"
                  + "((n3 in (n2.(left + right))) => (n3 !in (n.(left + right))))\n"
                  + "}) && (all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all n2: (one Node) {\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "}\n"
                  + "|\n"
                  + "((n2 = (n.left)) => (((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left))))\n"
                  + "|\n"
                  + "(((n2 != (n.right)) && (n2 = (n.right))) => (n2 != (n.left)))\n"
                  + "|\n"
                  + "((n2 != (n.right)) && (n2 = (n.right)))", 2)
          .put(
              "fun Depth[n: Node] : (one Int) {\n"
                  + "1\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "1\n"
                  + "}\n"
                  + "|\n"
                  + "1", 3)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) = 1)) || (((Depth[n1]) - (Depth[n2])) = 0) || (((Depth[n1]) - (Depth[n2])) = -1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) = 1)) || (((Depth[n1]) - (Depth[n2])) = 0) || (((Depth[n1]) - (Depth[n2])) = -1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) = 1)) || (((Depth[n1]) - (Depth[n2])) = 0) || (((Depth[n1]) - (Depth[n2])) = -1))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) = 1)) || (((Depth[n1]) - (Depth[n2])) = 0) || (((Depth[n1]) - (Depth[n2])) = -1))\n"
                  + "}\n"
                  + "|\n"
                  + "((((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) = 1)) || (((Depth[n1]) - (Depth[n2])) = 0) || (((Depth[n1]) - (Depth[n2])) = -1))\n"
                  + "|\n"
                  + "(((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) = 1))\n"
                  + "|\n"
                  + "(((Depth[n1]) - (Depth[n2])) = 1)\n"
                  + "|\n"
                  + "((Depth[n1]) - (Depth[n2]))", 4)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) = 1)) || (((Depth[n1]) - (Depth[n2])) = 0) || (((Depth[n1]) - (Depth[n2])) = -1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) = 1)) || (((Depth[n1]) - (Depth[n2])) = 0) || (((Depth[n1]) - (Depth[n2])) = -1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) = 1)) || (((Depth[n1]) - (Depth[n2])) = 0) || (((Depth[n1]) - (Depth[n2])) = -1))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) = 1)) || (((Depth[n1]) - (Depth[n2])) = 0) || (((Depth[n1]) - (Depth[n2])) = -1))\n"
                  + "}\n"
                  + "|\n"
                  + "((((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) = 1)) || (((Depth[n1]) - (Depth[n2])) = 0) || (((Depth[n1]) - (Depth[n2])) = -1))\n"
                  + "|\n"
                  + "(((Depth[n1]) - (Depth[n2])) = 0)\n"
                  + "|\n"
                  + "((Depth[n1]) - (Depth[n2]))", 4)
          .put(
              "pred Balanced[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) = 1)) || (((Depth[n1]) - (Depth[n2])) = 0) || (((Depth[n1]) - (Depth[n2])) = -1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) = 1)) || (((Depth[n1]) - (Depth[n2])) = 0) || (((Depth[n1]) - (Depth[n2])) = -1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "((((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) = 1)) || (((Depth[n1]) - (Depth[n2])) = 0) || (((Depth[n1]) - (Depth[n2])) = -1))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) = 1)) || (((Depth[n1]) - (Depth[n2])) = 0) || (((Depth[n1]) - (Depth[n2])) = -1))\n"
                  + "}\n"
                  + "|\n"
                  + "((((HasAtMostOneChild[n1]) && (HasAtMostOneChild[n2])) => (((Depth[n1]) - (Depth[n2])) = 1)) || (((Depth[n1]) - (Depth[n2])) = 0) || (((Depth[n1]) - (Depth[n2])) = -1))\n"
                  + "|\n"
                  + "(((Depth[n1]) - (Depth[n2])) = -1)\n"
                  + "|\n"
                  + "((Depth[n1]) - (Depth[n2]))", 4
          ).build()
  ),
  BEMPL_FAULTY(
      "bemplFaulty",
      ImmutableMap.of(
          "abstract sig Person {\n"
              + "owns: (set Key)\n"
              + "}\n"
              + "|\n"
              + "owns: (set Key)", 1)),
  CD_1(
      "cd1",
      ImmutableMap.<String, Integer>builder().put(
          "pred ObjectNoExt[] {\n"
              + "(all c: (one Class) {\n"
              + "(Object !in (c.(^ext)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all c: (one Class) {\n"
              + "(Object !in (c.(^ext)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all c: (one Class) {\n"
              + "(Object !in (c.(^ext)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(Object !in (c.(^ext)))\n"
              + "}\n"
              + "|\n"
              + "(Object !in (c.(^ext)))\n"
              + "|\n"
              + "(c.(^ext))\n"
              + "|\n"
              + "(^ext)", 1)
          .put(
              "pred ObjectNoExt[] {\n"
                  + "(all c: (one Class) {\n"
                  + "(Object !in (c.(^ext)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all c: (one Class) {\n"
                  + "(Object !in (c.(^ext)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all c: (one Class) {\n"
                  + "(Object !in (c.(^ext)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(Object !in (c.(^ext)))\n"
                  + "}\n"
                  + "|\n"
                  + "(Object !in (c.(^ext)))\n"
                  + "|\n"
                  + "(c.(^ext))\n"
                  + "|\n"
                  + "(^ext)\n"
                  + "|\n"
                  + "ext", 1)
          .put(
              "pred AllExtObject[] {\n"
                  + "(all c: (one (Class - Object)) {\n"
                  + "(c in (c.(*ext)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all c: (one (Class - Object)) {\n"
                  + "(c in (c.(*ext)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all c: (one (Class - Object)) {\n"
                  + "(c in (c.(*ext)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(c in (c.(*ext)))\n"
                  + "}\n"
                  + "|\n"
                  + "(c in (c.(*ext)))\n"
                  + "|\n"
                  + "c", 2)
          .put(
              "pred AllExtObject[] {\n"
                  + "(all c: (one (Class - Object)) {\n"
                  + "(c in (c.(*ext)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all c: (one (Class - Object)) {\n"
                  + "(c in (c.(*ext)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all c: (one (Class - Object)) {\n"
                  + "(c in (c.(*ext)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(c in (c.(*ext)))\n"
                  + "}\n"
                  + "|\n"
                  + "(c in (c.(*ext)))\n"
                  + "|\n"
                  + "(c.(*ext))", 2)
          .put(
              "pred AllExtObject[] {\n"
                  + "(all c: (one (Class - Object)) {\n"
                  + "(c in (c.(*ext)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all c: (one (Class - Object)) {\n"
                  + "(c in (c.(*ext)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all c: (one (Class - Object)) {\n"
                  + "(c in (c.(*ext)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(c in (c.(*ext)))\n"
                  + "}\n"
                  + "|\n"
                  + "(c in (c.(*ext)))\n"
                  + "|\n"
                  + "(c.(*ext))\n"
                  + "|\n"
                  + "c", 2)
          .put(
              "pred AllExtObject[] {\n"
                  + "(all c: (one (Class - Object)) {\n"
                  + "(c in (c.(*ext)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all c: (one (Class - Object)) {\n"
                  + "(c in (c.(*ext)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all c: (one (Class - Object)) {\n"
                  + "(c in (c.(*ext)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(c in (c.(*ext)))\n"
                  + "}\n"
                  + "|\n"
                  + "(c in (c.(*ext)))\n"
                  + "|\n"
                  + "(c.(*ext))\n"
                  + "|\n"
                  + "(*ext)", 2).build()),
  CD_2(
      "cd2",
      ImmutableMap.of(
          "pred Acyclic[] {\n"
              + "(no c: (one Class) {\n"
              + "(c = (c.ext))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(no c: (one Class) {\n"
              + "(c = (c.ext))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(no c: (one Class) {\n"
              + "(c = (c.ext))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(c = (c.ext))\n"
              + "}\n"
              + "|\n"
              + "(c = (c.ext))", 1,
          "pred Acyclic[] {\n"
              + "(no c: (one Class) {\n"
              + "(c = (c.ext))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(no c: (one Class) {\n"
              + "(c = (c.ext))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(no c: (one Class) {\n"
              + "(c = (c.ext))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(c = (c.ext))\n"
              + "}\n"
              + "|\n"
              + "(c = (c.ext))\n"
              + "|\n"
              + "(c.ext)\n"
              + "|\n"
              + "ext", 1)),
  CD_3(
      "cd3",
      ImmutableMap.of(
          "pred ObjectNoExt[] {\n"
              + "(all c: (one Class) {\n"
              + "(Object !in (c.(^ext)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all c: (one Class) {\n"
              + "(Object !in (c.(^ext)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all c: (one Class) {\n"
              + "(Object !in (c.(^ext)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(Object !in (c.(^ext)))\n"
              + "}\n"
              + "|\n"
              + "(Object !in (c.(^ext)))\n"
              + "|\n"
              + "(c.(^ext))\n"
              + "|\n"
              + "(^ext)", 1,
          "pred ObjectNoExt[] {\n"
              + "(all c: (one Class) {\n"
              + "(Object !in (c.(^ext)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all c: (one Class) {\n"
              + "(Object !in (c.(^ext)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all c: (one Class) {\n"
              + "(Object !in (c.(^ext)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(Object !in (c.(^ext)))\n"
              + "}\n"
              + "|\n"
              + "(Object !in (c.(^ext)))\n"
              + "|\n"
              + "(c.(^ext))\n"
              + "|\n"
              + "(^ext)\n"
              + "|\n"
              + "ext", 1,
          "pred AllExtObject[] {\n"
              + "(all c: (one (Class - Object)) {\n"
              + "(Object in ((c.ext).(^ext)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all c: (one (Class - Object)) {\n"
              + "(Object in ((c.ext).(^ext)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all c: (one (Class - Object)) {\n"
              + "(Object in ((c.ext).(^ext)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(Object in ((c.ext).(^ext)))\n"
              + "}\n"
              + "|\n"
              + "(Object in ((c.ext).(^ext)))\n"
              + "|\n"
              + "((c.ext).(^ext))\n"
              + "|\n"
              + "(c.ext)", 2,
          "pred AllExtObject[] {\n"
              + "(all c: (one (Class - Object)) {\n"
              + "(Object in ((c.ext).(^ext)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all c: (one (Class - Object)) {\n"
              + "(Object in ((c.ext).(^ext)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all c: (one (Class - Object)) {\n"
              + "(Object in ((c.ext).(^ext)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(Object in ((c.ext).(^ext)))\n"
              + "}\n"
              + "|\n"
              + "(Object in ((c.ext).(^ext)))\n"
              + "|\n"
              + "((c.ext).(^ext))\n"
              + "|\n"
              + "(c.ext)\n"
              + "|\n"
              + "ext", 2,
          "pred AllExtObject[] {\n"
              + "(all c: (one (Class - Object)) {\n"
              + "(Object in ((c.ext).(^ext)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all c: (one (Class - Object)) {\n"
              + "(Object in ((c.ext).(^ext)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all c: (one (Class - Object)) {\n"
              + "(Object in ((c.ext).(^ext)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(Object in ((c.ext).(^ext)))\n"
              + "}\n"
              + "|\n"
              + "(Object in ((c.ext).(^ext)))\n"
              + "|\n"
              + "((c.ext).(^ext))\n"
              + "|\n"
              + "(^ext)", 2)),
  CTREE_FAULTY(
      "ctreeFaulty",
      ImmutableMap.of(
          "fact undirected {\n"
              + "(neighbors = (~neighbors))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(neighbors = (~neighbors))\n"
              + "}", 1)),
  DLL_1(
      "dll1",
      ImmutableMap.of(
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "}", 1,
          "pred ConsistentPreAndNxt[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 != n2) => (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 != n2) => (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 != n2) => (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n1 != n2) => (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "}\n"
              + "|\n"
              + "((n1 != n2) => (((n1.nxt) = n2) <=> ((n2.pre) = n1)))", 2,
          "pred ConsistentPreAndNxt[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 != n2) => (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 != n2) => (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 != n2) => (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n1 != n2) => (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "}\n"
              + "|\n"
              + "((n1 != n2) => (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "|\n"
              + "(n1 != n2)", 2)),
  DLL_2(
      "dll2",
      ImmutableMap.of(
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "}", 1,
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "}\n"
              + "|\n"
              + "((n.elem) < ((n.nxt).elem))", 1,
          "pred ConsistentPreAndNxt[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((n1.nxt) = n2) => ((n2.pre) = n1))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((n1.nxt) = n2) => ((n2.pre) = n1))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((n1.nxt) = n2) => ((n2.pre) = n1))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((n1.nxt) = n2) => ((n2.pre) = n1))\n"
              + "}\n"
              + "|\n"
              + "(((n1.nxt) = n2) => ((n2.pre) = n1))", 2
      )),
  DLL_3(
      "dll3",
      ImmutableMap.<String, Integer>builder().put(
          "fact Acyclic {\n"
              + "(all n: (one Node) {\n"
              + "(n !in (n.(^(nxt + pre))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "(n !in (n.(^(nxt + pre))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "(n !in (n.(^(nxt + pre))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(n !in (n.(^(nxt + pre))))\n"
              + "}\n"
              + "|\n"
              + "(n !in (n.(^(nxt + pre))))\n"
              + "|\n"
              + "(n.(^(nxt + pre)))\n"
              + "|\n"
              + "(^(nxt + pre))\n"
              + "|\n"
              + "(nxt + pre)", 1)
          .put(
              "fact Acyclic {\n"
                  + "(all n: (one Node) {\n"
                  + "(n !in (n.(^(nxt + pre))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "(n !in (n.(^(nxt + pre))))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(n !in (n.(^(nxt + pre))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(n !in (n.(^(nxt + pre))))\n"
                  + "}\n"
                  + "|\n"
                  + "(n !in (n.(^(nxt + pre))))\n"
                  + "|\n"
                  + "(n.(^(nxt + pre)))\n"
                  + "|\n"
                  + "(^(nxt + pre))\n"
                  + "|\n"
                  + "(nxt + pre)\n"
                  + "|\n"
                  + "pre", 1)
          .put(
              "pred UniqueElem[] {\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "}", 2)
          .put(
              "pred UniqueElem[] {\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "}\n"
                  + "|\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)", 2)
          .put(
              "pred UniqueElem[] {\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "}\n"
                  + "|\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "|\n"
                  + "(((n.pre).elem) & ((n.nxt).elem))", 2)
          .put(
              "pred UniqueElem[] {\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "}\n"
                  + "|\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "|\n"
                  + "(((n.pre).elem) & ((n.nxt).elem))\n"
                  + "|\n"
                  + "((n.pre).elem)\n"
                  + "|\n"
                  + "(n.pre)", 2)
          .put(
              "pred UniqueElem[] {\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "}\n"
                  + "|\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "|\n"
                  + "(((n.pre).elem) & ((n.nxt).elem))\n"
                  + "|\n"
                  + "((n.pre).elem)\n"
                  + "|\n"
                  + "(n.pre)\n"
                  + "|\n"
                  + "pre", 2)
          .put(
              "pred UniqueElem[] {\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "}\n"
                  + "|\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "|\n"
                  + "(((n.pre).elem) & ((n.nxt).elem))\n"
                  + "|\n"
                  + "((n.nxt).elem)\n"
                  + "|\n"
                  + "(n.nxt)", 2)
          .put(
              "pred UniqueElem[] {\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "}\n"
                  + "|\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "|\n"
                  + "(((n.pre).elem) & ((n.nxt).elem))\n"
                  + "|\n"
                  + "((n.nxt).elem)\n"
                  + "|\n"
                  + "(n.nxt)\n"
                  + "|\n"
                  + "nxt", 2)
          .put(
              "pred UniqueElem[] {\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "}\n"
                  + "|\n"
                  + "((((n.pre).elem) & ((n.nxt).elem)) = none)\n"
                  + "|\n"
                  + "none", 2)
          .put(
              "pred ConsistentPreAndNxt[] {\n"
                  + "\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "\n"
                  + "}", 3).build()),
  DLL_4(
      "dll4",
      ImmutableMap.of(
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "(((n.nxt).elem) > (n.elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "(((n.nxt).elem) > (n.elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "(((n.nxt).elem) > (n.elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((n.nxt).elem) > (n.elem))\n"
              + "}", 1,
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "(((n.nxt).elem) > (n.elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "(((n.nxt).elem) > (n.elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "(((n.nxt).elem) > (n.elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((n.nxt).elem) > (n.elem))\n"
              + "}\n"
              + "|\n"
              + "(((n.nxt).elem) > (n.elem))", 1)),
  DLL_5(
      "dll5",
      ImmutableMap.of(
          "pred UniqueElem[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "}\n"
              + "|\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "|\n"
              + "(((n1.(*nxt)).elem) != ((n2.(*nxt)).elem))\n"
              + "|\n"
              + "((n1.(*nxt)).elem)\n"
              + "|\n"
              + "(n1.(*nxt))", 1,
          "pred UniqueElem[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "}\n"
              + "|\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "|\n"
              + "(((n1.(*nxt)).elem) != ((n2.(*nxt)).elem))\n"
              + "|\n"
              + "((n1.(*nxt)).elem)\n"
              + "|\n"
              + "(n1.(*nxt))\n"
              + "|\n"
              + "(*nxt)", 1,
          "pred UniqueElem[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "}\n"
              + "|\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "|\n"
              + "(((n1.(*nxt)).elem) != ((n2.(*nxt)).elem))\n"
              + "|\n"
              + "((n2.(*nxt)).elem)\n"
              + "|\n"
              + "(n2.(*nxt))", 1,
          "pred UniqueElem[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "}\n"
              + "|\n"
              + "((n1 = n2) || (((n1.(*nxt)).elem) != ((n2.(*nxt)).elem)))\n"
              + "|\n"
              + "(((n1.(*nxt)).elem) != ((n2.(*nxt)).elem))\n"
              + "|\n"
              + "((n2.(*nxt)).elem)\n"
              + "|\n"
              + "(n2.(*nxt))\n"
              + "|\n"
              + "(*nxt)", 1,
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "(all n': (one (((n.nxt).(*nxt)).elem)) {\n"
              + "(n' > (n.elem))\n"
              + "})\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "(all n': (one (((n.nxt).(*nxt)).elem)) {\n"
              + "(n' > (n.elem))\n"
              + "})\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "(all n': (one (((n.nxt).(*nxt)).elem)) {\n"
              + "(n' > (n.elem))\n"
              + "})\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(all n': (one (((n.nxt).(*nxt)).elem)) {\n"
              + "(n' > (n.elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n': (one (((n.nxt).(*nxt)).elem)) {\n"
              + "(n' > (n.elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(n' > (n.elem))\n"
              + "}\n"
              + "|\n"
              + "(n' > (n.elem))", 2
      )
  ),
  DLL_6(
      "dll6",
      ImmutableMap.of(
          "pred Sorted[] {\n"
              + "(all n1: (one ((DLL.header).(*nxt))) {\n"
              + "((n1.elem) <= ((n1.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1: (one ((DLL.header).(*nxt))) {\n"
              + "((n1.elem) <= ((n1.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1: (one ((DLL.header).(*nxt))) {\n"
              + "((n1.elem) <= ((n1.nxt).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n1.elem) <= ((n1.nxt).elem))\n"
              + "}", 1,
          "pred ConsistentPreAndNxt[] {\n"
              + "((all n1: (one ((DLL.header).(*nxt))),n2: (one ((DLL.header).(*nxt))) {\n"
              + "((n1 = n2) || (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "}) && (all n1: (one ((DLL.header).(*nxt))) {\n"
              + "((n1.pre) != n1)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all n1: (one ((DLL.header).(*nxt))),n2: (one ((DLL.header).(*nxt))) {\n"
              + "((n1 = n2) || (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "}) && (all n1: (one ((DLL.header).(*nxt))) {\n"
              + "((n1.pre) != n1)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all n1: (one ((DLL.header).(*nxt))),n2: (one ((DLL.header).(*nxt))) {\n"
              + "((n1 = n2) || (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "}) && (all n1: (one ((DLL.header).(*nxt))) {\n"
              + "((n1.pre) != n1)\n"
              + "}))", 2,
          "pred ConsistentPreAndNxt[] {\n"
              + "((all n1: (one ((DLL.header).(*nxt))),n2: (one ((DLL.header).(*nxt))) {\n"
              + "((n1 = n2) || (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "}) && (all n1: (one ((DLL.header).(*nxt))) {\n"
              + "((n1.pre) != n1)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all n1: (one ((DLL.header).(*nxt))),n2: (one ((DLL.header).(*nxt))) {\n"
              + "((n1 = n2) || (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "}) && (all n1: (one ((DLL.header).(*nxt))) {\n"
              + "((n1.pre) != n1)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all n1: (one ((DLL.header).(*nxt))),n2: (one ((DLL.header).(*nxt))) {\n"
              + "((n1 = n2) || (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "}) && (all n1: (one ((DLL.header).(*nxt))) {\n"
              + "((n1.pre) != n1)\n"
              + "}))\n"
              + "|\n"
              + "(all n1: (one ((DLL.header).(*nxt))),n2: (one ((DLL.header).(*nxt))) {\n"
              + "((n1 = n2) || (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n1 = n2) || (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "}\n"
              + "|\n"
              + "((n1 = n2) || (((n1.nxt) = n2) <=> ((n2.pre) = n1)))", 2,
          "pred ConsistentPreAndNxt[] {\n"
              + "((all n1: (one ((DLL.header).(*nxt))),n2: (one ((DLL.header).(*nxt))) {\n"
              + "((n1 = n2) || (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "}) && (all n1: (one ((DLL.header).(*nxt))) {\n"
              + "((n1.pre) != n1)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all n1: (one ((DLL.header).(*nxt))),n2: (one ((DLL.header).(*nxt))) {\n"
              + "((n1 = n2) || (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "}) && (all n1: (one ((DLL.header).(*nxt))) {\n"
              + "((n1.pre) != n1)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all n1: (one ((DLL.header).(*nxt))),n2: (one ((DLL.header).(*nxt))) {\n"
              + "((n1 = n2) || (((n1.nxt) = n2) <=> ((n2.pre) = n1)))\n"
              + "}) && (all n1: (one ((DLL.header).(*nxt))) {\n"
              + "((n1.pre) != n1)\n"
              + "}))\n"
              + "|\n"
              + "(all n1: (one ((DLL.header).(*nxt))) {\n"
              + "((n1.pre) != n1)\n"
              + "})", 2
      )
  ),
  DLL_7(
      "dll7",
      ImmutableMap.of(
          "fact Acyclic {\n"
              + "((all n: (one Node) {\n"
              + "(n !in (n.(^nxt)))\n"
              + "}) && (all n: (one Node) {\n"
              + "(n !in (n.(^pre)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all n: (one Node) {\n"
              + "(n !in (n.(^nxt)))\n"
              + "}) && (all n: (one Node) {\n"
              + "(n !in (n.(^pre)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all n: (one Node) {\n"
              + "(n !in (n.(^nxt)))\n"
              + "}) && (all n: (one Node) {\n"
              + "(n !in (n.(^pre)))\n"
              + "}))", 1,
          "fact Acyclic {\n"
              + "((all n: (one Node) {\n"
              + "(n !in (n.(^nxt)))\n"
              + "}) && (all n: (one Node) {\n"
              + "(n !in (n.(^pre)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all n: (one Node) {\n"
              + "(n !in (n.(^nxt)))\n"
              + "}) && (all n: (one Node) {\n"
              + "(n !in (n.(^pre)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all n: (one Node) {\n"
              + "(n !in (n.(^nxt)))\n"
              + "}) && (all n: (one Node) {\n"
              + "(n !in (n.(^pre)))\n"
              + "}))\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "(n !in (n.(^pre)))\n"
              + "})", 1,
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "}", 2
      )
  ),
  DLL_8(
      "dll8",
      ImmutableMap.of(
          "pred Sorted[] {\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) <= ((n.(^nxt)).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) <= ((n.(^nxt)).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) <= ((n.(^nxt)).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.(^nxt)).elem))\n"
              + "}", 1,
          "pred Sorted[] {\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) <= ((n.(^nxt)).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) <= ((n.(^nxt)).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) <= ((n.(^nxt)).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.(^nxt)).elem))\n"
              + "}\n"
              + "|\n"
              + "((n.elem) <= ((n.(^nxt)).elem))\n"
              + "|\n"
              + "((n.(^nxt)).elem)\n"
              + "|\n"
              + "(n.(^nxt))\n"
              + "|\n"
              + "(^nxt)", 1
      )
  ),
  DLL_9(
      "dll9",
      ImmutableMap.of(
          "pred Sorted[] {\n"
              + "((#(Node.pre)) <= (#(Node.nxt)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((#(Node.pre)) <= (#(Node.nxt)))\n"
              + "}", 1,
          "pred Sorted[] {\n"
              + "((#(Node.pre)) <= (#(Node.nxt)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((#(Node.pre)) <= (#(Node.nxt)))\n"
              + "}\n"
              + "|\n"
              + "((#(Node.pre)) <= (#(Node.nxt)))", 1,
          "pred Sorted[] {\n"
              + "((#(Node.pre)) <= (#(Node.nxt)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((#(Node.pre)) <= (#(Node.nxt)))\n"
              + "}\n"
              + "|\n"
              + "((#(Node.pre)) <= (#(Node.nxt)))\n"
              + "|\n"
              + "(#(Node.pre))\n"
              + "|\n"
              + "(Node.pre)", 1,
          "pred Sorted[] {\n"
              + "((#(Node.pre)) <= (#(Node.nxt)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((#(Node.pre)) <= (#(Node.nxt)))\n"
              + "}\n"
              + "|\n"
              + "((#(Node.pre)) <= (#(Node.nxt)))\n"
              + "|\n"
              + "(#(Node.nxt))\n"
              + "|\n"
              + "(Node.nxt)", 1
      )
  ),
  DLL_10(
      "dll10",
      ImmutableMap.of(
          "fact Acyclic {\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "}\n"
              + "|\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))", 1,
          "fact Acyclic {\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "}\n"
              + "|\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "|\n"
              + "(n !in (n.(^pre)))", 1
      )
  ),
  DLL_11(
      "dll11",
      ImmutableMap.of(
          "pred Sorted[] {\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "}", 1,
          "pred Sorted[] {\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "}\n"
              + "|\n"
              + "((n.elem) < ((n.nxt).elem))", 1
      )
  ),
  DLL_12(
      "dll12",
      ImmutableMap.of(
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "}", 1
      )
  ),
  DLL_13(
      "dll13",
      ImmutableMap.of(
          "pred UniqueElem[] {\n"
              + "(all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "})", 1,
          "pred UniqueElem[] {\n"
              + "(all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(one (n.elem))\n"
              + "}", 1,
          "pred UniqueElem[] {\n"
              + "(all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(one (n.elem))\n"
              + "}\n"
              + "|\n"
              + "(one (n.elem))", 1,
          "pred UniqueElem[] {\n"
              + "(all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(one (n.elem))\n"
              + "}\n"
              + "|\n"
              + "(one (n.elem))\n"
              + "|\n"
              + "(n.elem)", 1
      )
  ),
  DLL_14(
      "dll14",
      ImmutableMap.of(
          "fact Acyclic {\n"
              + "((all n: (one Node) {\n"
              + "(n !in (n.(^nxt)))\n"
              + "}) && (all n: (one Node) {\n"
              + "(n !in (n.(^pre)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all n: (one Node) {\n"
              + "(n !in (n.(^nxt)))\n"
              + "}) && (all n: (one Node) {\n"
              + "(n !in (n.(^pre)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all n: (one Node) {\n"
              + "(n !in (n.(^nxt)))\n"
              + "}) && (all n: (one Node) {\n"
              + "(n !in (n.(^pre)))\n"
              + "}))", 1,
          "fact Acyclic {\n"
              + "((all n: (one Node) {\n"
              + "(n !in (n.(^nxt)))\n"
              + "}) && (all n: (one Node) {\n"
              + "(n !in (n.(^pre)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all n: (one Node) {\n"
              + "(n !in (n.(^nxt)))\n"
              + "}) && (all n: (one Node) {\n"
              + "(n !in (n.(^pre)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all n: (one Node) {\n"
              + "(n !in (n.(^nxt)))\n"
              + "}) && (all n: (one Node) {\n"
              + "(n !in (n.(^pre)))\n"
              + "}))\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "(n !in (n.(^pre)))\n"
              + "})", 1,
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "}", 2
      )
  ),
  DLL_15(
      "dll15",
      ImmutableMap.of(
          "pred Sorted[] {\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "}", 1,
          "pred Sorted[] {\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) < ((n.nxt).elem))\n"
              + "}\n"
              + "|\n"
              + "((n.elem) < ((n.nxt).elem))", 1,
          "pred ConsistentPreAndNxt[] {\n"
              + "(all n1,n2: (one ((DLL.header).(*nxt))) {\n"
              + "((n1 != n2) => ((((n1.nxt) = n2) => ((n2.pre) = n1)) && (((n1.pre) = n2) => ((n2.nxt) = n1))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one ((DLL.header).(*nxt))) {\n"
              + "((n1 != n2) => ((((n1.nxt) = n2) => ((n2.pre) = n1)) && (((n1.pre) = n2) => ((n2.nxt) = n1))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one ((DLL.header).(*nxt))) {\n"
              + "((n1 != n2) => ((((n1.nxt) = n2) => ((n2.pre) = n1)) && (((n1.pre) = n2) => ((n2.nxt) = n1))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n1 != n2) => ((((n1.nxt) = n2) => ((n2.pre) = n1)) && (((n1.pre) = n2) => ((n2.nxt) = n1))))\n"
              + "}\n"
              + "|\n"
              + "((n1 != n2) => ((((n1.nxt) = n2) => ((n2.pre) = n1)) && (((n1.pre) = n2) => ((n2.nxt) = n1))))",
          2,
          "pred ConsistentPreAndNxt[] {\n"
              + "(all n1,n2: (one ((DLL.header).(*nxt))) {\n"
              + "((n1 != n2) => ((((n1.nxt) = n2) => ((n2.pre) = n1)) && (((n1.pre) = n2) => ((n2.nxt) = n1))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one ((DLL.header).(*nxt))) {\n"
              + "((n1 != n2) => ((((n1.nxt) = n2) => ((n2.pre) = n1)) && (((n1.pre) = n2) => ((n2.nxt) = n1))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one ((DLL.header).(*nxt))) {\n"
              + "((n1 != n2) => ((((n1.nxt) = n2) => ((n2.pre) = n1)) && (((n1.pre) = n2) => ((n2.nxt) = n1))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n1 != n2) => ((((n1.nxt) = n2) => ((n2.pre) = n1)) && (((n1.pre) = n2) => ((n2.nxt) = n1))))\n"
              + "}\n"
              + "|\n"
              + "((n1 != n2) => ((((n1.nxt) = n2) => ((n2.pre) = n1)) && (((n1.pre) = n2) => ((n2.nxt) = n1))))\n"
              + "|\n"
              + "(n1 != n2)", 2
      )
  ),
  DLL_16(
      "dll16",
      ImmutableMap.of(
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "}", 1
      )
  ),
  DLL_17(
      "dll17",
      ImmutableMap.of(
          "fact Acyclic {\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "}\n"
              + "|\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))", 1,
          "fact Acyclic {\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "}\n"
              + "|\n"
              + "((n !in (n.(^nxt))) && (n !in (n.(^pre))))\n"
              + "|\n"
              + "(n !in (n.(^pre)))", 1,
          "pred Sorted[] {\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.nxt).elem))\n"
              + "}", 2,
          "pred ConsistentPreAndNxt[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((n1.nxt) = n2) => ((n2.pre) = n1))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((n1.nxt) = n2) => ((n2.pre) = n1))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "(((n1.nxt) = n2) => ((n2.pre) = n1))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((n1.nxt) = n2) => ((n2.pre) = n1))\n"
              + "}\n"
              + "|\n"
              + "(((n1.nxt) = n2) => ((n2.pre) = n1))", 3
      )
  ),
  DLL_18(
      "dll18",
      ImmutableMap.<String, Integer>builder().put(
          "fact Acyclic {\n"
              + "(no n: (one Node) {\n"
              + "(n = (n.nxt))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(no n: (one Node) {\n"
              + "(n = (n.nxt))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(no n: (one Node) {\n"
              + "(n = (n.nxt))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(n = (n.nxt))\n"
              + "}\n"
              + "|\n"
              + "(n = (n.nxt))", 1)
          .put(
              "fact Acyclic {\n"
                  + "(no n: (one Node) {\n"
                  + "(n = (n.nxt))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(no n: (one Node) {\n"
                  + "(n = (n.nxt))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(no n: (one Node) {\n"
                  + "(n = (n.nxt))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(n = (n.nxt))\n"
                  + "}\n"
                  + "|\n"
                  + "(n = (n.nxt))\n"
                  + "|\n"
                  + "(n.nxt)\n"
                  + "|\n"
                  + "nxt", 1)
          .put(
              "pred UniqueElem[] {\n"
                  + "(all i: (one Int),n1,n2: (one (Node.elem)) {\n"
                  + "(((i = n1) && (i = n2)) => (n1 = n2))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all i: (one Int),n1,n2: (one (Node.elem)) {\n"
                  + "(((i = n1) && (i = n2)) => (n1 = n2))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all i: (one Int),n1,n2: (one (Node.elem)) {\n"
                  + "(((i = n1) && (i = n2)) => (n1 = n2))\n"
                  + "})\n"
                  + "|\n"
                  + "n1,n2: (one (Node.elem))\n"
                  + "|\n"
                  + "(one (Node.elem))\n"
                  + "|\n"
                  + "(Node.elem)", 2)
          .put(
              "pred UniqueElem[] {\n"
                  + "(all i: (one Int),n1,n2: (one (Node.elem)) {\n"
                  + "(((i = n1) && (i = n2)) => (n1 = n2))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all i: (one Int),n1,n2: (one (Node.elem)) {\n"
                  + "(((i = n1) && (i = n2)) => (n1 = n2))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all i: (one Int),n1,n2: (one (Node.elem)) {\n"
                  + "(((i = n1) && (i = n2)) => (n1 = n2))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((i = n1) && (i = n2)) => (n1 = n2))\n"
                  + "}\n"
                  + "|\n"
                  + "(((i = n1) && (i = n2)) => (n1 = n2))\n"
                  + "|\n"
                  + "((i = n1) && (i = n2))\n"
                  + "|\n"
                  + "(i = n1)\n"
                  + "|\n"
                  + "n1", 2)
          .put(
              "pred UniqueElem[] {\n"
                  + "(all i: (one Int),n1,n2: (one (Node.elem)) {\n"
                  + "(((i = n1) && (i = n2)) => (n1 = n2))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all i: (one Int),n1,n2: (one (Node.elem)) {\n"
                  + "(((i = n1) && (i = n2)) => (n1 = n2))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all i: (one Int),n1,n2: (one (Node.elem)) {\n"
                  + "(((i = n1) && (i = n2)) => (n1 = n2))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((i = n1) && (i = n2)) => (n1 = n2))\n"
                  + "}\n"
                  + "|\n"
                  + "(((i = n1) && (i = n2)) => (n1 = n2))\n"
                  + "|\n"
                  + "((i = n1) && (i = n2))\n"
                  + "|\n"
                  + "(i = n2)\n"
                  + "|\n"
                  + "n2", 2)
          .put(
              "pred Sorted[] {\n"
                  + "(all i1,i2: (one Int),n1,n2: (one Node) {\n"
                  + "(((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2)) => ((i1 < i2) && ((n1.nxt) = n2)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all i1,i2: (one Int),n1,n2: (one Node) {\n"
                  + "(((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2)) => ((i1 < i2) && ((n1.nxt) = n2)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all i1,i2: (one Int),n1,n2: (one Node) {\n"
                  + "(((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2)) => ((i1 < i2) && ((n1.nxt) = n2)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2)) => ((i1 < i2) && ((n1.nxt) = n2)))\n"
                  + "}\n"
                  + "|\n"
                  + "(((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2)) => ((i1 < i2) && ((n1.nxt) = n2)))\n"
                  + "|\n"
                  + "((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2))\n"
                  + "|\n"
                  + "(((n1.nxt).elem) = i1)\n"
                  + "|\n"
                  + "((n1.nxt).elem)\n"
                  + "|\n"
                  + "(n1.nxt)", 3)
          .put(
              "pred Sorted[] {\n"
                  + "(all i1,i2: (one Int),n1,n2: (one Node) {\n"
                  + "(((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2)) => ((i1 < i2) && ((n1.nxt) = n2)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all i1,i2: (one Int),n1,n2: (one Node) {\n"
                  + "(((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2)) => ((i1 < i2) && ((n1.nxt) = n2)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all i1,i2: (one Int),n1,n2: (one Node) {\n"
                  + "(((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2)) => ((i1 < i2) && ((n1.nxt) = n2)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2)) => ((i1 < i2) && ((n1.nxt) = n2)))\n"
                  + "}\n"
                  + "|\n"
                  + "(((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2)) => ((i1 < i2) && ((n1.nxt) = n2)))\n"
                  + "|\n"
                  + "((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2))\n"
                  + "|\n"
                  + "(((n2.nxt).elem) = i2)\n"
                  + "|\n"
                  + "((n2.nxt).elem)\n"
                  + "|\n"
                  + "(n2.nxt)", 3)
          .put(
              "pred Sorted[] {\n"
                  + "(all i1,i2: (one Int),n1,n2: (one Node) {\n"
                  + "(((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2)) => ((i1 < i2) && ((n1.nxt) = n2)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all i1,i2: (one Int),n1,n2: (one Node) {\n"
                  + "(((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2)) => ((i1 < i2) && ((n1.nxt) = n2)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all i1,i2: (one Int),n1,n2: (one Node) {\n"
                  + "(((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2)) => ((i1 < i2) && ((n1.nxt) = n2)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2)) => ((i1 < i2) && ((n1.nxt) = n2)))\n"
                  + "}\n"
                  + "|\n"
                  + "(((((n1.nxt).elem) = i1) && (((n2.nxt).elem) = i2)) => ((i1 < i2) && ((n1.nxt) = n2)))\n"
                  + "|\n"
                  + "((i1 < i2) && ((n1.nxt) = n2))", 3)
          .put(
              "pred ConsistentPreAndNxt[] {\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((n1.nxt) = n2) => ((n2.pre) = n1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((n1.nxt) = n2) => ((n2.pre) = n1))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n1,n2: (one Node) {\n"
                  + "(((n1.nxt) = n2) => ((n2.pre) = n1))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((n1.nxt) = n2) => ((n2.pre) = n1))\n"
                  + "}\n"
                  + "|\n"
                  + "(((n1.nxt) = n2) => ((n2.pre) = n1))", 4
          ).build()
  ),
  DLL_19(
      "dll19",
      ImmutableMap.of(
          "pred Sorted[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n2 in (n1.(^nxt))) => ((n1.elem) < (n2.elem)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n2 in (n1.(^nxt))) => ((n1.elem) < (n2.elem)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n2 in (n1.(^nxt))) => ((n1.elem) < (n2.elem)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n2 in (n1.(^nxt))) => ((n1.elem) < (n2.elem)))\n"
              + "}\n"
              + "|\n"
              + "((n2 in (n1.(^nxt))) => ((n1.elem) < (n2.elem)))\n"
              + "|\n"
              + "((n1.elem) < (n2.elem))", 1
      )
  ),
  DLL_20(
      "dll20",
      ImmutableMap.of(
          "fact Acyclic {\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "(n !in (n.(^(pre + nxt))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "(n !in (n.(^(pre + nxt))))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((DLL.header).(*nxt))) {\n"
              + "(n !in (n.(^(pre + nxt))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(n !in (n.(^(pre + nxt))))\n"
              + "}\n"
              + "|\n"
              + "(n !in (n.(^(pre + nxt))))\n"
              + "|\n"
              + "(n.(^(pre + nxt)))\n"
              + "|\n"
              + "(^(pre + nxt))\n"
              + "|\n"
              + "(pre + nxt)", 1,
          "pred Sorted[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n2 in (n1.(^nxt))) => ((n1.elem) < (n2.elem)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n2 in (n1.(^nxt))) => ((n1.elem) < (n2.elem)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n2 in (n1.(^nxt))) => ((n1.elem) < (n2.elem)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n2 in (n1.(^nxt))) => ((n1.elem) < (n2.elem)))\n"
              + "}\n"
              + "|\n"
              + "((n2 in (n1.(^nxt))) => ((n1.elem) < (n2.elem)))\n"
              + "|\n"
              + "((n1.elem) < (n2.elem))", 2,
          "pred ConsistentPreAndNxt[] {\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n2 in (n1.nxt)) => (n1 in (n2.pre)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n2 in (n1.nxt)) => (n1 in (n2.pre)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n1,n2: (one Node) {\n"
              + "((n2 in (n1.nxt)) => (n1 in (n2.pre)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n2 in (n1.nxt)) => (n1 in (n2.pre)))\n"
              + "}\n"
              + "|\n"
              + "((n2 in (n1.nxt)) => (n1 in (n2.pre)))", 3
      )
  ),
  FARMER_FAULTY(
      "farmerFaulty",
      ImmutableMap.of(
          "pred crossRiver[from,from',to,to': (set Object)] {\n"
              + "(((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer))) || (some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer))) || (some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "(((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer))) || (some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}))\n"
              + "|\n"
              + "((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer)))\n"
              + "|\n"
              + "(from' = (from - Farmer))\n"
              + "|\n"
              + "(from - Farmer)", 1,
          "pred crossRiver[from,from',to,to': (set Object)] {\n"
              + "(((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer))) || (some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer))) || (some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "(((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer))) || (some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}))\n"
              + "|\n"
              + "((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer)))\n"
              + "|\n"
              + "(to' = ((to - (to.eats)) + Farmer))\n"
              + "|\n"
              + "((to - (to.eats)) + Farmer)\n"
              + "|\n"
              + "(to - (to.eats))", 1,
          "pred crossRiver[from,from',to,to': (set Object)] {\n"
              + "(((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer))) || (some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer))) || (some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "(((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer))) || (some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}))\n"
              + "|\n"
              + "(some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}\n"
              + "|\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "|\n"
              + "(from' = ((from - Farmer) - item))\n"
              + "|\n"
              + "((from - Farmer) - item)", 1,
          "pred crossRiver[from,from',to,to': (set Object)] {\n"
              + "(((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer))) || (some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer))) || (some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "(((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer))) || (some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}))\n"
              + "|\n"
              + "(some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}\n"
              + "|\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "|\n"
              + "(from' = ((from - Farmer) - item))\n"
              + "|\n"
              + "((from - Farmer) - item)\n"
              + "|\n"
              + "(from - Farmer)", 1,
          "pred crossRiver[from,from',to,to': (set Object)] {\n"
              + "(((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer))) || (some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer))) || (some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "(((from' = (from - Farmer)) && (to' = ((to - (to.eats)) + Farmer))) || (some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}))\n"
              + "|\n"
              + "(some item: (one (from - Farmer)) {\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "}\n"
              + "|\n"
              + "((from' = ((from - Farmer) - item)) && (to' = (((to - (to.eats)) + Farmer) + item)))\n"
              + "|\n"
              + "(to' = (((to - (to.eats)) + Farmer) + item))\n"
              + "|\n"
              + "(((to - (to.eats)) + Farmer) + item)\n"
              + "|\n"
              + "((to - (to.eats)) + Farmer)\n"
              + "|\n"
              + "(to - (to.eats))", 1)),
  FSM_1(
      "fsm1",
      ImmutableMap.of(
          "fact ValidStartAndStop {\n"
              + "(((FSM.start) !in (FSM.stop)) && (all s: (one State) {\n"
              + "((s.transition) !in (FSM.start))\n"
              + "}) && (all s: (one State) {\n"
              + "(((s.transition) = none) => (s in (FSM.stop)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(((FSM.start) !in (FSM.stop)) && (all s: (one State) {\n"
              + "((s.transition) !in (FSM.start))\n"
              + "}) && (all s: (one State) {\n"
              + "(((s.transition) = none) => (s in (FSM.stop)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "(((FSM.start) !in (FSM.stop)) && (all s: (one State) {\n"
              + "((s.transition) !in (FSM.start))\n"
              + "}) && (all s: (one State) {\n"
              + "(((s.transition) = none) => (s in (FSM.stop)))\n"
              + "}))\n"
              + "|\n"
              + "(all s: (one State) {\n"
              + "((s.transition) !in (FSM.start))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((s.transition) !in (FSM.start))\n"
              + "}", 1,
          "fact ValidStartAndStop {\n"
              + "(((FSM.start) !in (FSM.stop)) && (all s: (one State) {\n"
              + "((s.transition) !in (FSM.start))\n"
              + "}) && (all s: (one State) {\n"
              + "(((s.transition) = none) => (s in (FSM.stop)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(((FSM.start) !in (FSM.stop)) && (all s: (one State) {\n"
              + "((s.transition) !in (FSM.start))\n"
              + "}) && (all s: (one State) {\n"
              + "(((s.transition) = none) => (s in (FSM.stop)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "(((FSM.start) !in (FSM.stop)) && (all s: (one State) {\n"
              + "((s.transition) !in (FSM.start))\n"
              + "}) && (all s: (one State) {\n"
              + "(((s.transition) = none) => (s in (FSM.stop)))\n"
              + "}))\n"
              + "|\n"
              + "(all s: (one State) {\n"
              + "((s.transition) !in (FSM.start))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((s.transition) !in (FSM.start))\n"
              + "}\n"
              + "|\n"
              + "((s.transition) !in (FSM.start))", 1,
          "fact ValidStartAndStop {\n"
              + "(((FSM.start) !in (FSM.stop)) && (all s: (one State) {\n"
              + "((s.transition) !in (FSM.start))\n"
              + "}) && (all s: (one State) {\n"
              + "(((s.transition) = none) => (s in (FSM.stop)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(((FSM.start) !in (FSM.stop)) && (all s: (one State) {\n"
              + "((s.transition) !in (FSM.start))\n"
              + "}) && (all s: (one State) {\n"
              + "(((s.transition) = none) => (s in (FSM.stop)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "(((FSM.start) !in (FSM.stop)) && (all s: (one State) {\n"
              + "((s.transition) !in (FSM.start))\n"
              + "}) && (all s: (one State) {\n"
              + "(((s.transition) = none) => (s in (FSM.stop)))\n"
              + "}))\n"
              + "|\n"
              + "(all s: (one State) {\n"
              + "(((s.transition) = none) => (s in (FSM.stop)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(((s.transition) = none) => (s in (FSM.stop)))\n"
              + "}\n"
              + "|\n"
              + "(((s.transition) = none) => (s in (FSM.stop)))", 2
      )
  ),
  FSM_2(
      "fsm2",
      ImmutableMap.of(
          "fact ValidStartAndStop {\n"
              + "(((FSM.start) != (FSM.stop)) && (all s: (one State) {\n"
              + "((FSM.start) != (s.transition))\n"
              + "}) && (no ((FSM.stop).transition)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(((FSM.start) != (FSM.stop)) && (all s: (one State) {\n"
              + "((FSM.start) != (s.transition))\n"
              + "}) && (no ((FSM.stop).transition)))\n"
              + "}\n"
              + "|\n"
              + "(((FSM.start) != (FSM.stop)) && (all s: (one State) {\n"
              + "((FSM.start) != (s.transition))\n"
              + "}) && (no ((FSM.stop).transition)))\n"
              + "|\n"
              + "(all s: (one State) {\n"
              + "((FSM.start) != (s.transition))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((FSM.start) != (s.transition))\n"
              + "}\n"
              + "|\n"
              + "((FSM.start) != (s.transition))", 1
      )
  ),
  FSM_3(
      "fsm3",
      ImmutableMap.<String, Integer>builder().put(
          "fact Reachability {\n"
              + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
              + "}\n"
              + "|\n"
              + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
              + "|\n"
              + "((FSM.stop) = ((State.(*transition)).(^transition)))", 1)
          .put(
              "fact Reachability {\n"
                  + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
                  + "|\n"
                  + "((FSM.stop) = ((State.(*transition)).(^transition)))\n"
                  + "|\n"
                  + "((State.(*transition)).(^transition))", 1)
          .put(
              "fact Reachability {\n"
                  + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
                  + "|\n"
                  + "((FSM.stop) = ((State.(*transition)).(^transition)))\n"
                  + "|\n"
                  + "((State.(*transition)).(^transition))\n"
                  + "|\n"
                  + "(State.(*transition))", 1)
          .put(
              "fact Reachability {\n"
                  + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
                  + "|\n"
                  + "((FSM.stop) = ((State.(*transition)).(^transition)))\n"
                  + "|\n"
                  + "((State.(*transition)).(^transition))\n"
                  + "|\n"
                  + "(State.(*transition))\n"
                  + "|\n"
                  + "State", 1)
          .put(
              "fact Reachability {\n"
                  + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
                  + "|\n"
                  + "((FSM.stop) = ((State.(*transition)).(^transition)))\n"
                  + "|\n"
                  + "((State.(*transition)).(^transition))\n"
                  + "|\n"
                  + "(^transition)", 1)
          .put(
              "fact Reachability {\n"
                  + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "((State = ((FSM.start).(*transition))) && ((FSM.stop) = ((State.(*transition)).(^transition))))\n"
                  + "|\n"
                  + "((FSM.stop) = ((State.(*transition)).(^transition)))\n"
                  + "|\n"
                  + "((State.(*transition)).(^transition))\n"
                  + "|\n"
                  + "(^transition)\n"
                  + "|\n"
                  + "transition", 1
          ).build()
  ),
  FSM_4(
      "fsm4",
      ImmutableMap.of(
          "fact OneStartAndStop {\n"
              + "((some s1: (one State) {\n"
              + "(s1 in (FSM.start))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.start)) && (s2 = (FSM.start))) => (s1 = s2))\n"
              + "}) && (some s1: (one State) {\n"
              + "(s1 in (FSM.stop))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.stop)) && (s2 = (FSM.stop))) => (s1 = s2))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((some s1: (one State) {\n"
              + "(s1 in (FSM.start))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.start)) && (s2 = (FSM.start))) => (s1 = s2))\n"
              + "}) && (some s1: (one State) {\n"
              + "(s1 in (FSM.stop))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.stop)) && (s2 = (FSM.stop))) => (s1 = s2))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((some s1: (one State) {\n"
              + "(s1 in (FSM.start))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.start)) && (s2 = (FSM.start))) => (s1 = s2))\n"
              + "}) && (some s1: (one State) {\n"
              + "(s1 in (FSM.stop))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.stop)) && (s2 = (FSM.stop))) => (s1 = s2))\n"
              + "}))\n"
              + "|\n"
              + "(some s1: (one State) {\n"
              + "(s1 in (FSM.start))\n"
              + "})", 1,
          "fact OneStartAndStop {\n"
              + "((some s1: (one State) {\n"
              + "(s1 in (FSM.start))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.start)) && (s2 = (FSM.start))) => (s1 = s2))\n"
              + "}) && (some s1: (one State) {\n"
              + "(s1 in (FSM.stop))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.stop)) && (s2 = (FSM.stop))) => (s1 = s2))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((some s1: (one State) {\n"
              + "(s1 in (FSM.start))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.start)) && (s2 = (FSM.start))) => (s1 = s2))\n"
              + "}) && (some s1: (one State) {\n"
              + "(s1 in (FSM.stop))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.stop)) && (s2 = (FSM.stop))) => (s1 = s2))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((some s1: (one State) {\n"
              + "(s1 in (FSM.start))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.start)) && (s2 = (FSM.start))) => (s1 = s2))\n"
              + "}) && (some s1: (one State) {\n"
              + "(s1 in (FSM.stop))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.stop)) && (s2 = (FSM.stop))) => (s1 = s2))\n"
              + "}))\n"
              + "|\n"
              + "(some s1: (one State) {\n"
              + "(s1 in (FSM.start))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(s1 in (FSM.start))\n"
              + "}\n"
              + "|\n"
              + "(s1 in (FSM.start))", 1,
          "fact OneStartAndStop {\n"
              + "((some s1: (one State) {\n"
              + "(s1 in (FSM.start))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.start)) && (s2 = (FSM.start))) => (s1 = s2))\n"
              + "}) && (some s1: (one State) {\n"
              + "(s1 in (FSM.stop))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.stop)) && (s2 = (FSM.stop))) => (s1 = s2))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((some s1: (one State) {\n"
              + "(s1 in (FSM.start))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.start)) && (s2 = (FSM.start))) => (s1 = s2))\n"
              + "}) && (some s1: (one State) {\n"
              + "(s1 in (FSM.stop))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.stop)) && (s2 = (FSM.stop))) => (s1 = s2))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((some s1: (one State) {\n"
              + "(s1 in (FSM.start))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.start)) && (s2 = (FSM.start))) => (s1 = s2))\n"
              + "}) && (some s1: (one State) {\n"
              + "(s1 in (FSM.stop))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.stop)) && (s2 = (FSM.stop))) => (s1 = s2))\n"
              + "}))\n"
              + "|\n"
              + "(some s1: (one State) {\n"
              + "(s1 in (FSM.stop))\n"
              + "})", 2,
          "fact OneStartAndStop {\n"
              + "((some s1: (one State) {\n"
              + "(s1 in (FSM.start))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.start)) && (s2 = (FSM.start))) => (s1 = s2))\n"
              + "}) && (some s1: (one State) {\n"
              + "(s1 in (FSM.stop))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.stop)) && (s2 = (FSM.stop))) => (s1 = s2))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((some s1: (one State) {\n"
              + "(s1 in (FSM.start))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.start)) && (s2 = (FSM.start))) => (s1 = s2))\n"
              + "}) && (some s1: (one State) {\n"
              + "(s1 in (FSM.stop))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.stop)) && (s2 = (FSM.stop))) => (s1 = s2))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((some s1: (one State) {\n"
              + "(s1 in (FSM.start))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.start)) && (s2 = (FSM.start))) => (s1 = s2))\n"
              + "}) && (some s1: (one State) {\n"
              + "(s1 in (FSM.stop))\n"
              + "}) && (all s1,s2: (one State) {\n"
              + "(((s1 = (FSM.stop)) && (s2 = (FSM.stop))) => (s1 = s2))\n"
              + "}))\n"
              + "|\n"
              + "(some s1: (one State) {\n"
              + "(s1 in (FSM.stop))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(s1 in (FSM.stop))\n"
              + "}\n"
              + "|\n"
              + "(s1 in (FSM.stop))", 2
      )
  ),
  FSM_5(
      "fsm5",
      ImmutableMap.<String, Integer>builder().put(
          "fact ValidStartAndStop {\n"
              + "((all x: (one FSM) {\n"
              + "((x.start)disjoint (x.stop))\n"
              + "}) && (all x: (one FSM),y: (one State) {\n"
              + "((x.start) !in (y.transition))\n"
              + "}) && (all x: (one FSM),y: (one State) {\n"
              + "((x.stop) !in (y.(~transition)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all x: (one FSM) {\n"
              + "((x.start)disjoint (x.stop))\n"
              + "}) && (all x: (one FSM),y: (one State) {\n"
              + "((x.start) !in (y.transition))\n"
              + "}) && (all x: (one FSM),y: (one State) {\n"
              + "((x.stop) !in (y.(~transition)))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all x: (one FSM) {\n"
              + "((x.start)disjoint (x.stop))\n"
              + "}) && (all x: (one FSM),y: (one State) {\n"
              + "((x.start) !in (y.transition))\n"
              + "}) && (all x: (one FSM),y: (one State) {\n"
              + "((x.stop) !in (y.(~transition)))\n"
              + "}))\n"
              + "|\n"
              + "(all x: (one FSM),y: (one State) {\n"
              + "((x.start) !in (y.transition))\n"
              + "})", 1)
          .put(
              "fact ValidStartAndStop {\n"
                  + "((all x: (one FSM) {\n"
                  + "((x.start)disjoint (x.stop))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all x: (one FSM) {\n"
                  + "((x.start)disjoint (x.stop))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all x: (one FSM) {\n"
                  + "((x.start)disjoint (x.stop))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}", 1)
          .put(
              "fact ValidStartAndStop {\n"
                  + "((all x: (one FSM) {\n"
                  + "((x.start)disjoint (x.stop))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all x: (one FSM) {\n"
                  + "((x.start)disjoint (x.stop))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all x: (one FSM) {\n"
                  + "((x.start)disjoint (x.stop))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}\n"
                  + "|\n"
                  + "((x.start) !in (y.transition))", 1)
          .put(
              "fact ValidStartAndStop {\n"
                  + "((all x: (one FSM) {\n"
                  + "((x.start)disjoint (x.stop))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all x: (one FSM) {\n"
                  + "((x.start)disjoint (x.stop))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all x: (one FSM) {\n"
                  + "((x.start)disjoint (x.stop))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "})", 2)
          .put(
              "fact ValidStartAndStop {\n"
                  + "((all x: (one FSM) {\n"
                  + "((x.start)disjoint (x.stop))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all x: (one FSM) {\n"
                  + "((x.start)disjoint (x.stop))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all x: (one FSM) {\n"
                  + "((x.start)disjoint (x.stop))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}", 2)
          .put(
              "fact ValidStartAndStop {\n"
                  + "((all x: (one FSM) {\n"
                  + "((x.start)disjoint (x.stop))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all x: (one FSM) {\n"
                  + "((x.start)disjoint (x.stop))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all x: (one FSM) {\n"
                  + "((x.start)disjoint (x.stop))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.start) !in (y.transition))\n"
                  + "}) && (all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all x: (one FSM),y: (one State) {\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((x.stop) !in (y.(~transition)))\n"
                  + "}\n"
                  + "|\n"
                  + "((x.stop) !in (y.(~transition)))", 2)
          .put(
              "fact Reachability {\n"
                  + "((State = ((FSM.start).(*transition))) && (((#(State.transition)) + 1) = (#(FSM.stop))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((State = ((FSM.start).(*transition))) && (((#(State.transition)) + 1) = (#(FSM.stop))))\n"
                  + "}\n"
                  + "|\n"
                  + "((State = ((FSM.start).(*transition))) && (((#(State.transition)) + 1) = (#(FSM.stop))))\n"
                  + "|\n"
                  + "(((#(State.transition)) + 1) = (#(FSM.stop)))", 3)
          .put(
              "fact Reachability {\n"
                  + "((State = ((FSM.start).(*transition))) && (((#(State.transition)) + 1) = (#(FSM.stop))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((State = ((FSM.start).(*transition))) && (((#(State.transition)) + 1) = (#(FSM.stop))))\n"
                  + "}\n"
                  + "|\n"
                  + "((State = ((FSM.start).(*transition))) && (((#(State.transition)) + 1) = (#(FSM.stop))))\n"
                  + "|\n"
                  + "(((#(State.transition)) + 1) = (#(FSM.stop)))\n"
                  + "|\n"
                  + "((#(State.transition)) + 1)", 3
          ).build()
  ),
  FSM_6(
      "fsm6",
      ImmutableMap.<String, Integer>builder().put(
          "fact Reachability {\n"
              + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
              + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
              + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
              + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
              + "}))\n"
              + "|\n"
              + "(all s: (one State) {\n"
              + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
              + "}", 1)
          .put(
              "fact Reachability {\n"
                  + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))", 1)
          .put(
              "fact Reachability {\n"
                  + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "|\n"
                  + "(s = (FSM.stop))", 1)
          .put(
              "fact Reachability {\n"
                  + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "|\n"
                  + "(s in ((FSM.start).(*transition)))", 1)
          .put(
              "fact Reachability {\n"
                  + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "|\n"
                  + "(s in ((FSM.start).(*transition)))\n"
                  + "|\n"
                  + "((FSM.start).(*transition))", 1)
          .put(
              "fact Reachability {\n"
                  + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((State = ((FSM.start).(*transition))) && (all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all s: (one State) {\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "((s = (FSM.stop)) || (s in ((FSM.start).(*transition))))\n"
                  + "|\n"
                  + "(s in ((FSM.start).(*transition)))\n"
                  + "|\n"
                  + "((FSM.start).(*transition))\n"
                  + "|\n"
                  + "(FSM.start)", 1
          ).build()
  ),
  FSM_7(
      "fsm7",
      ImmutableMap.<String, Integer>builder().put(
          "fact ValidStartAndStop {\n"
              + "(((FSM.start) != (FSM.stop)) && ((#((FSM.start).transition)) != 0) && ((#((FSM.stop).transition)) = 0))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(((FSM.start) != (FSM.stop)) && ((#((FSM.start).transition)) != 0) && ((#((FSM.stop).transition)) = 0))\n"
              + "}\n"
              + "|\n"
              + "(((FSM.start) != (FSM.stop)) && ((#((FSM.start).transition)) != 0) && ((#((FSM.stop).transition)) = 0))\n"
              + "|\n"
              + "((#((FSM.start).transition)) != 0)", 1)
          .put(
              "fact ValidStartAndStop {\n"
                  + "(((FSM.start) != (FSM.stop)) && ((#((FSM.start).transition)) != 0) && ((#((FSM.stop).transition)) = 0))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(((FSM.start) != (FSM.stop)) && ((#((FSM.start).transition)) != 0) && ((#((FSM.stop).transition)) = 0))\n"
                  + "}\n"
                  + "|\n"
                  + "(((FSM.start) != (FSM.stop)) && ((#((FSM.start).transition)) != 0) && ((#((FSM.stop).transition)) = 0))\n"
                  + "|\n"
                  + "((#((FSM.start).transition)) != 0)\n"
                  + "|\n"
                  + "(#((FSM.start).transition))\n"
                  + "|\n"
                  + "((FSM.start).transition)", 1)
          .put(
              "fact Reachability {\n"
                  + "((State in ((FSM.start).(*transition))) && ((FSM.stop) in (State.(*transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((State in ((FSM.start).(*transition))) && ((FSM.stop) in (State.(*transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "((State in ((FSM.start).(*transition))) && ((FSM.stop) in (State.(*transition))))",
              2)
          .put(
              "fact Reachability {\n"
                  + "((State in ((FSM.start).(*transition))) && ((FSM.stop) in (State.(*transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((State in ((FSM.start).(*transition))) && ((FSM.stop) in (State.(*transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "((State in ((FSM.start).(*transition))) && ((FSM.stop) in (State.(*transition))))\n"
                  + "|\n"
                  + "((FSM.stop) in (State.(*transition)))", 2)
          .put(
              "fact Reachability {\n"
                  + "((State in ((FSM.start).(*transition))) && ((FSM.stop) in (State.(*transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((State in ((FSM.start).(*transition))) && ((FSM.stop) in (State.(*transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "((State in ((FSM.start).(*transition))) && ((FSM.stop) in (State.(*transition))))\n"
                  + "|\n"
                  + "((FSM.stop) in (State.(*transition)))\n"
                  + "|\n"
                  + "(State.(*transition))", 2)
          .put(
              "fact Reachability {\n"
                  + "((State in ((FSM.start).(*transition))) && ((FSM.stop) in (State.(*transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((State in ((FSM.start).(*transition))) && ((FSM.stop) in (State.(*transition))))\n"
                  + "}\n"
                  + "|\n"
                  + "((State in ((FSM.start).(*transition))) && ((FSM.stop) in (State.(*transition))))\n"
                  + "|\n"
                  + "((FSM.stop) in (State.(*transition)))\n"
                  + "|\n"
                  + "(State.(*transition))\n"
                  + "|\n"
                  + "State", 2
          ).build()
  ),
  FSM_8(
      "fsm8",
      ImmutableMap.of(
          "fact ValidStartAndStop {\n"
              + "(((FSM.start) != (FSM.stop)) && (all s: (one State) {\n"
              + "((s.(*transition)) != (FSM.start))\n"
              + "}) && (no ((FSM.stop).transition)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(((FSM.start) != (FSM.stop)) && (all s: (one State) {\n"
              + "((s.(*transition)) != (FSM.start))\n"
              + "}) && (no ((FSM.stop).transition)))\n"
              + "}\n"
              + "|\n"
              + "(((FSM.start) != (FSM.stop)) && (all s: (one State) {\n"
              + "((s.(*transition)) != (FSM.start))\n"
              + "}) && (no ((FSM.stop).transition)))\n"
              + "|\n"
              + "(all s: (one State) {\n"
              + "((s.(*transition)) != (FSM.start))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((s.(*transition)) != (FSM.start))\n"
              + "}\n"
              + "|\n"
              + "((s.(*transition)) != (FSM.start))", 1,
          "fact ValidStartAndStop {\n"
              + "(((FSM.start) != (FSM.stop)) && (all s: (one State) {\n"
              + "((s.(*transition)) != (FSM.start))\n"
              + "}) && (no ((FSM.stop).transition)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(((FSM.start) != (FSM.stop)) && (all s: (one State) {\n"
              + "((s.(*transition)) != (FSM.start))\n"
              + "}) && (no ((FSM.stop).transition)))\n"
              + "}\n"
              + "|\n"
              + "(((FSM.start) != (FSM.stop)) && (all s: (one State) {\n"
              + "((s.(*transition)) != (FSM.start))\n"
              + "}) && (no ((FSM.stop).transition)))\n"
              + "|\n"
              + "(all s: (one State) {\n"
              + "((s.(*transition)) != (FSM.start))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((s.(*transition)) != (FSM.start))\n"
              + "}\n"
              + "|\n"
              + "((s.(*transition)) != (FSM.start))\n"
              + "|\n"
              + "(s.(*transition))\n"
              + "|\n"
              + "(*transition)", 1
      )
  ),
  FSM_9(
      "fsm9",
      ImmutableMap.<String, Integer>builder().put(
          "fact ValidStartAndStop {\n"
              + "((all s: (one State) {\n"
              + "((start.s) != (stop.s))\n"
              + "}) && (no s: (one State) {\n"
              + "((FSM.start) = (s.transition))\n"
              + "}) && (no s: (one State) {\n"
              + "((s.transition) = (FSM.stop))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all s: (one State) {\n"
              + "((start.s) != (stop.s))\n"
              + "}) && (no s: (one State) {\n"
              + "((FSM.start) = (s.transition))\n"
              + "}) && (no s: (one State) {\n"
              + "((s.transition) = (FSM.stop))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all s: (one State) {\n"
              + "((start.s) != (stop.s))\n"
              + "}) && (no s: (one State) {\n"
              + "((FSM.start) = (s.transition))\n"
              + "}) && (no s: (one State) {\n"
              + "((s.transition) = (FSM.stop))\n"
              + "}))\n"
              + "|\n"
              + "(all s: (one State) {\n"
              + "((start.s) != (stop.s))\n"
              + "})", 1)
          .put(
              "fact ValidStartAndStop {\n"
                  + "((all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((start.s) != (stop.s))\n"
                  + "}\n"
                  + "|\n"
                  + "((start.s) != (stop.s))\n"
                  + "|\n"
                  + "(start.s)", 1)
          .put(
              "fact ValidStartAndStop {\n"
                  + "((all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((start.s) != (stop.s))\n"
                  + "}\n"
                  + "|\n"
                  + "((start.s) != (stop.s))\n"
                  + "|\n"
                  + "(stop.s)", 1)
          .put(
              "fact ValidStartAndStop {\n"
                  + "((all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}))\n"
                  + "|\n"
                  + "(no s: (one State) {\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "}\n"
                  + "|\n"
                  + "((FSM.start) = (s.transition))", 2)
          .put(
              "fact ValidStartAndStop {\n"
                  + "((all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}))\n"
                  + "|\n"
                  + "(no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}\n"
                  + "|\n"
                  + "((s.transition) = (FSM.stop))", 3)
          .put(
              "fact ValidStartAndStop {\n"
                  + "((all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all s: (one State) {\n"
                  + "((start.s) != (stop.s))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((FSM.start) = (s.transition))\n"
                  + "}) && (no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}))\n"
                  + "|\n"
                  + "(no s: (one State) {\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "}\n"
                  + "|\n"
                  + "((s.transition) = (FSM.stop))\n"
                  + "|\n"
                  + "(s.transition)", 3)
          .put(
              "fact Reachability {\n"
                  + "((all s: (one State) {\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "}) && (all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all s: (one State) {\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "}) && (all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all s: (one State) {\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "}) && (all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}))\n"
                  + "|\n"
                  + "(all s: (one State) {\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "}\n"
                  + "|\n"
                  + "(s = ((FSM.start).(*transition)))", 4)
          .put(
              "fact Reachability {\n"
                  + "((all s: (one State) {\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "}) && (all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all s: (one State) {\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "}) && (all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all s: (one State) {\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "}) && (all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}))\n"
                  + "|\n"
                  + "(all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}\n"
                  + "|\n"
                  + "(((FSM.stop).(*transition)) = s)", 5)
          .put(
              "fact Reachability {\n"
                  + "((all s: (one State) {\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "}) && (all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all s: (one State) {\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "}) && (all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all s: (one State) {\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "}) && (all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}))\n"
                  + "|\n"
                  + "(all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}\n"
                  + "|\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "|\n"
                  + "((FSM.stop).(*transition))", 5)
          .put(
              "fact Reachability {\n"
                  + "((all s: (one State) {\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "}) && (all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all s: (one State) {\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "}) && (all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all s: (one State) {\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "}) && (all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}))\n"
                  + "|\n"
                  + "(all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}\n"
                  + "|\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "|\n"
                  + "((FSM.stop).(*transition))\n"
                  + "|\n"
                  + "(*transition)", 5)
          .put(
              "fact Reachability {\n"
                  + "((all s: (one State) {\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "}) && (all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all s: (one State) {\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "}) && (all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((all s: (one State) {\n"
                  + "(s = ((FSM.start).(*transition)))\n"
                  + "}) && (all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}))\n"
                  + "|\n"
                  + "(all s: (one State) {\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "}\n"
                  + "|\n"
                  + "(((FSM.stop).(*transition)) = s)\n"
                  + "|\n"
                  + "((FSM.stop).(*transition))\n"
                  + "|\n"
                  + "(*transition)\n"
                  + "|\n"
                  + "transition", 5
          ).build()
  ),
  GRADE_FAULTY(
      "gradeFaulty",
      ImmutableMap.of(
          "pred PolicyAllowsGrading[s: Person,a: Assignment] {\n"
              + "((s in ((a.associated_with).assistant_for)) || (s in ((a.associated_with).instructor_of)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((s in ((a.associated_with).assistant_for)) || (s in ((a.associated_with).instructor_of)))\n"
              + "}", 1)),
  OTHER_FAULTY(
      "otherFaulty",
      ImmutableMap.of(
          "fact fact_1 {\n"
              + "((alas in (seclab.located_in)) && (peds in (seclab.located_in)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((alas in (seclab.located_in)) && (peds in (seclab.located_in)))\n"
              + "}\n"
              + "|\n"
              + "((alas in (seclab.located_in)) && (peds in (seclab.located_in)))", 1,
          "fact fact_1 {\n"
              + "((alas in (seclab.located_in)) && (peds in (seclab.located_in)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((alas in (seclab.located_in)) && (peds in (seclab.located_in)))\n"
              + "}\n"
              + "|\n"
              + "((alas in (seclab.located_in)) && (peds in (seclab.located_in)))\n"
              + "|\n"
              + "(alas in (seclab.located_in))", 1,
          "fact fact_1 {\n"
              + "((alas in (seclab.located_in)) && (peds in (seclab.located_in)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((alas in (seclab.located_in)) && (peds in (seclab.located_in)))\n"
              + "}\n"
              + "|\n"
              + "((alas in (seclab.located_in)) && (peds in (seclab.located_in)))\n"
              + "|\n"
              + "(peds in (seclab.located_in))", 1)),
  STUDENT_1(
      "student1",
      ImmutableMap.of(
          "pred Sorted[This: List] {\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "}", 1)),
  STUDENT_2(
      "student2",
      ImmutableMap.of(
          "pred Sorted[This: List] {\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "}", 1,
          "pred Contains[This: List,x: Int,result: Boolean] {\n"
              + "((RepOk[This]) && (((x !in (((This.header).(*link)).elem)) => (result = False)) || (result = True)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((RepOk[This]) && (((x !in (((This.header).(*link)).elem)) => (result = False)) || (result = True)))\n"
              + "}\n"
              + "|\n"
              + "((RepOk[This]) && (((x !in (((This.header).(*link)).elem)) => (result = False)) || (result = True)))\n"
              + "|\n"
              + "(((x !in (((This.header).(*link)).elem)) => (result = False)) || (result = True))",
          2,
          "pred Contains[This: List,x: Int,result: Boolean] {\n"
              + "((RepOk[This]) && (((x !in (((This.header).(*link)).elem)) => (result = False)) || (result = True)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((RepOk[This]) && (((x !in (((This.header).(*link)).elem)) => (result = False)) || (result = True)))\n"
              + "}\n"
              + "|\n"
              + "((RepOk[This]) && (((x !in (((This.header).(*link)).elem)) => (result = False)) || (result = True)))\n"
              + "|\n"
              + "(((x !in (((This.header).(*link)).elem)) => (result = False)) || (result = True))\n"
              + "|\n"
              + "((x !in (((This.header).(*link)).elem)) => (result = False))", 2)),
  STUDENT_3(
      "student3",
      ImmutableMap.<String, Integer>builder().put(
          "pred Loop[This: List] {\n"
              + "((no n: (one Node) {\n"
              + "(n = ((n - (This.header)).link))\n"
              + "}) && (one n: (one Node) {\n"
              + "((n.link) = (This.header))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((no n: (one Node) {\n"
              + "(n = ((n - (This.header)).link))\n"
              + "}) && (one n: (one Node) {\n"
              + "((n.link) = (This.header))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((no n: (one Node) {\n"
              + "(n = ((n - (This.header)).link))\n"
              + "}) && (one n: (one Node) {\n"
              + "((n.link) = (This.header))\n"
              + "}))", 1)
          .put(
              "pred Loop[This: List] {\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "|\n"
                  + "(no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "})", 1)
          .put(
              "pred Loop[This: List] {\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "|\n"
                  + "(no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}\n"
                  + "|\n"
                  + "(n = ((n - (This.header)).link))", 1)
          .put(
              "pred Loop[This: List] {\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "|\n"
                  + "(no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}\n"
                  + "|\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "|\n"
                  + "((n - (This.header)).link)", 1)
          .put(
              "pred Loop[This: List] {\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "|\n"
                  + "(no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}\n"
                  + "|\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "|\n"
                  + "((n - (This.header)).link)\n"
                  + "|\n"
                  + "(n - (This.header))", 1)
          .put(
              "pred Loop[This: List] {\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "|\n"
                  + "(one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "})", 2)
          .put(
              "pred Loop[This: List] {\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "|\n"
                  + "(one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "})\n"
                  + "|\n"
                  + "n: (one Node)\n"
                  + "|\n"
                  + "(one Node)\n"
                  + "|\n"
                  + "Node", 2)
          .put(
              "pred Loop[This: List] {\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "|\n"
                  + "(one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((n.link) = (This.header))\n"
                  + "}\n"
                  + "|\n"
                  + "((n.link) = (This.header))", 2)
          .put(
              "pred Loop[This: List] {\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((no n: (one Node) {\n"
                  + "(n = ((n - (This.header)).link))\n"
                  + "}) && (one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "}))\n"
                  + "|\n"
                  + "(one n: (one Node) {\n"
                  + "((n.link) = (This.header))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((n.link) = (This.header))\n"
                  + "}\n"
                  + "|\n"
                  + "((n.link) = (This.header))\n"
                  + "|\n"
                  + "(This.header)", 2)
          .put(
              "pred Sorted[This: List] {\n"
                  + "(all n: (one Node) {\n"
                  + "((n.elem) <= (((n.link) - (This.header)).elem))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((n.elem) <= (((n.link) - (This.header)).elem))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((n.elem) <= (((n.link) - (This.header)).elem))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((n.elem) <= (((n.link) - (This.header)).elem))\n"
                  + "}", 3)
          .put(
              "pred Sorted[This: List] {\n"
                  + "(all n: (one Node) {\n"
                  + "((n.elem) <= (((n.link) - (This.header)).elem))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((n.elem) <= (((n.link) - (This.header)).elem))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((n.elem) <= (((n.link) - (This.header)).elem))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((n.elem) <= (((n.link) - (This.header)).elem))\n"
                  + "}\n"
                  + "|\n"
                  + "((n.elem) <= (((n.link) - (This.header)).elem))\n"
                  + "|\n"
                  + "(((n.link) - (This.header)).elem)\n"
                  + "|\n"
                  + "((n.link) - (This.header))", 3)
          .put(
              "pred Sorted[This: List] {\n"
                  + "(all n: (one Node) {\n"
                  + "((n.elem) <= (((n.link) - (This.header)).elem))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((n.elem) <= (((n.link) - (This.header)).elem))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((n.elem) <= (((n.link) - (This.header)).elem))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((n.elem) <= (((n.link) - (This.header)).elem))\n"
                  + "}\n"
                  + "|\n"
                  + "((n.elem) <= (((n.link) - (This.header)).elem))\n"
                  + "|\n"
                  + "(((n.link) - (This.header)).elem)\n"
                  + "|\n"
                  + "((n.link) - (This.header))\n"
                  + "|\n"
                  + "(This.header)", 3).build()),
  STUDENT_4(
      "student4",
      ImmutableMap.of(
          "pred Sorted[This: List] {\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "}", 1)),
  STUDENT_5(
      "student5",
      ImmutableMap.of(
          "pred Sorted[This: List] {\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "}", 1)),
  STUDENT_6(
      "student6",
      ImmutableMap.<String, Integer>builder().put(
          "fact CardinalityConstraints {\n"
              + "((((List.header).(*link)) = Node) && (all l: (one List) {\n"
              + "(one (l.header))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.link))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((((List.header).(*link)) = Node) && (all l: (one List) {\n"
              + "(one (l.header))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.link))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((((List.header).(*link)) = Node) && (all l: (one List) {\n"
              + "(one (l.header))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.link))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "}))\n"
              + "|\n"
              + "(all l: (one List) {\n"
              + "(one (l.header))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(one (l.header))\n"
              + "}\n"
              + "|\n"
              + "(one (l.header))", 1)
          .put(
              "fact CardinalityConstraints {\n"
                  + "((((List.header).(*link)) = Node) && (all l: (one List) {\n"
                  + "(one (l.header))\n"
                  + "}) && (all n: (one Node) {\n"
                  + "(one (n.link))\n"
                  + "}) && (all n: (one Node) {\n"
                  + "(one (n.elem))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((((List.header).(*link)) = Node) && (all l: (one List) {\n"
                  + "(one (l.header))\n"
                  + "}) && (all n: (one Node) {\n"
                  + "(one (n.link))\n"
                  + "}) && (all n: (one Node) {\n"
                  + "(one (n.elem))\n"
                  + "}))\n"
                  + "}\n"
                  + "|\n"
                  + "((((List.header).(*link)) = Node) && (all l: (one List) {\n"
                  + "(one (l.header))\n"
                  + "}) && (all n: (one Node) {\n"
                  + "(one (n.link))\n"
                  + "}) && (all n: (one Node) {\n"
                  + "(one (n.elem))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(one (n.link))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(one (n.link))\n"
                  + "}\n"
                  + "|\n"
                  + "(one (n.link))", 2)
          .put(
              "pred Loop[This: List] {\n"
                  + "(one n: (one ((This.header).(*link))) {\n"
                  + "(n in (n.(^link)))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(one n: (one ((This.header).(*link))) {\n"
                  + "(n in (n.(^link)))\n"
                  + "})\n"
                  + "}", 3)
          .put(
              "pred Sorted[This: List] {\n"
                  + "(all n: (one ((This.header).(*link))) {\n"
                  + "((n.elem) <= ((n.link).elem))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one ((This.header).(*link))) {\n"
                  + "((n.elem) <= ((n.link).elem))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one ((This.header).(*link))) {\n"
                  + "((n.elem) <= ((n.link).elem))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((n.elem) <= ((n.link).elem))\n"
                  + "}", 4).build()),
  STUDENT_7(
      "student7",
      ImmutableMap.<String, Integer>builder().put(
          "pred Loop[This: List] {\n"
              + "((all n: (one Node) {\n"
              + "(n in (((This.header).link).(^link)))\n"
              + "}) && ((#header) > 0))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all n: (one Node) {\n"
              + "(n in (((This.header).link).(^link)))\n"
              + "}) && ((#header) > 0))\n"
              + "}\n"
              + "|\n"
              + "((all n: (one Node) {\n"
              + "(n in (((This.header).link).(^link)))\n"
              + "}) && ((#header) > 0))", 1)
          .put(
              "pred Loop[This: List] {\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "})", 1)
          .put(
              "pred Loop[This: List] {\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "})\n"
                  + "|\n"
                  + "n: (one Node)\n"
                  + "|\n"
                  + "(one Node)\n"
                  + "|\n"
                  + "Node", 1)
          .put(
              "pred Loop[This: List] {\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}\n"
                  + "|\n"
                  + "(n in (((This.header).link).(^link)))", 1)
          .put(
              "pred Loop[This: List] {\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}\n"
                  + "|\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "|\n"
                  + "(((This.header).link).(^link))", 1)
          .put(
              "pred Loop[This: List] {\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}\n"
                  + "|\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "|\n"
                  + "(((This.header).link).(^link))\n"
                  + "|\n"
                  + "((This.header).link)", 1)
          .put(
              "pred Loop[This: List] {\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}\n"
                  + "|\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "|\n"
                  + "(((This.header).link).(^link))\n"
                  + "|\n"
                  + "((This.header).link)\n"
                  + "|\n"
                  + "(This.header)", 1)
          .put(
              "pred Loop[This: List] {\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}\n"
                  + "|\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "|\n"
                  + "(((This.header).link).(^link))\n"
                  + "|\n"
                  + "(^link)", 1)
          .put(
              "pred Loop[This: List] {\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "}\n"
                  + "|\n"
                  + "((all n: (one Node) {\n"
                  + "(n in (((This.header).link).(^link)))\n"
                  + "}) && ((#header) > 0))\n"
                  + "|\n"
                  + "((#header) > 0)", 2)
          .put(
              "pred Sorted[This: List] {\n"
                  + "(all n: (one Node) {\n"
                  + "((n.elem) <= ((n.link).elem))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "(all n: (one Node) {\n"
                  + "((n.elem) <= ((n.link).elem))\n"
                  + "})\n"
                  + "}\n"
                  + "|\n"
                  + "(all n: (one Node) {\n"
                  + "((n.elem) <= ((n.link).elem))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((n.elem) <= ((n.link).elem))\n"
                  + "}", 3).build()),
  STUDENT_8(
      "student8",
      ImmutableMap.of(
          "pred Sorted[This: List] {\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "}", 1)),
  STUDENT_9(
      "student9",
      ImmutableMap.of(
          "pred Contains[This: List,x: Int,result: Boolean] {\n"
              + "((RepOk[This]) && ((some n: (one ((This.header).(*link))) {\n"
              + "((n.elem) = x)\n"
              + "}) => (True = result)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((RepOk[This]) && ((some n: (one ((This.header).(*link))) {\n"
              + "((n.elem) = x)\n"
              + "}) => (True = result)))\n"
              + "}\n"
              + "|\n"
              + "((RepOk[This]) && ((some n: (one ((This.header).(*link))) {\n"
              + "((n.elem) = x)\n"
              + "}) => (True = result)))\n"
              + "|\n"
              + "((some n: (one ((This.header).(*link))) {\n"
              + "((n.elem) = x)\n"
              + "}) => (True = result))", 1)),
  STUDENT_10(
      "student10",
      ImmutableMap.of(
          "pred Sorted[This: List] {\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "}", 1)),
  STUDENT_11(
      "student11",
      ImmutableMap.of(
          "pred Sorted[This: List] {\n"
              + "((no (This.header)) || (all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((no (This.header)) || (all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((no (This.header)) || (all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "}))\n"
              + "|\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "}", 1)),
  STUDENT_12(
      "student12",
      ImmutableMap.of(
          "pred Sorted[This: List] {\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.(^link)).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.(^link)).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.(^link)).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.(^link)).elem))\n"
              + "}", 1,
          "pred Sorted[This: List] {\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.(^link)).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.(^link)).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.(^link)).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.(^link)).elem))\n"
              + "}\n"
              + "|\n"
              + "((n.elem) <= ((n.(^link)).elem))\n"
              + "|\n"
              + "((n.(^link)).elem)\n"
              + "|\n"
              + "(n.(^link))\n"
              + "|\n"
              + "(^link)", 1,
          "pred Contains[This: List,x: Int,result: Boolean] {\n"
              + "((RepOk[This]) && ((all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) = x)\n"
              + "}) => (result = True) else (result = False)))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((RepOk[This]) && ((all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) = x)\n"
              + "}) => (result = True) else (result = False)))\n"
              + "}\n"
              + "|\n"
              + "((RepOk[This]) && ((all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) = x)\n"
              + "}) => (result = True) else (result = False)))\n"
              + "|\n"
              + "((all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) = x)\n"
              + "}) => (result = True) else (result = False))\n"
              + "|\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) = x)\n"
              + "})", 2)),
  STUDENT_13(
      "student13",
      ImmutableMap.of(
          "pred Loop[This: List] {\n"
              + "((no (This.header)) || (one n: (one ((This.header).(*link))) {\n"
              + "((n.link) in n)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((no (This.header)) || (one n: (one ((This.header).(*link))) {\n"
              + "((n.link) in n)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((no (This.header)) || (one n: (one ((This.header).(*link))) {\n"
              + "((n.link) in n)\n"
              + "}))\n"
              + "|\n"
              + "(one n: (one ((This.header).(*link))) {\n"
              + "((n.link) in n)\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.link) in n)\n"
              + "}\n"
              + "|\n"
              + "((n.link) in n)", 1)),
  STUDENT_14(
      "student14",
      ImmutableMap.of(
          "fact CardinalityConstraints {\n"
              + "((all l: (one List) {\n"
              + "(one (l.header))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.link))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all l: (one List) {\n"
              + "(one (l.header))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.link))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all l: (one List) {\n"
              + "(one (l.header))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.link))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "}))\n"
              + "|\n"
              + "(all l: (one List) {\n"
              + "(one (l.header))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(one (l.header))\n"
              + "}\n"
              + "|\n"
              + "(one (l.header))", 1,
          "fact CardinalityConstraints {\n"
              + "((all l: (one List) {\n"
              + "(one (l.header))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.link))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((all l: (one List) {\n"
              + "(one (l.header))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.link))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((all l: (one List) {\n"
              + "(one (l.header))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.link))\n"
              + "}) && (all n: (one Node) {\n"
              + "(one (n.elem))\n"
              + "}))\n"
              + "|\n"
              + "(all n: (one Node) {\n"
              + "(one (n.link))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "(one (n.link))\n"
              + "}\n"
              + "|\n"
              + "(one (n.link))", 2,
          "pred Loop[This: List] {\n"
              + "(one n: (one ((This.header).(*link))) {\n"
              + "(n in (n.(^link)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(one n: (one ((This.header).(*link))) {\n"
              + "(n in (n.(^link)))\n"
              + "})\n"
              + "}", 3,
          "pred Sorted[This: List] {\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "}", 4)),
  STUDENT_15(
      "student15",
      ImmutableMap.of(
          "pred Sorted[This: List] {\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "}", 1)),
  STUDENT_16(
      "student16",
      ImmutableMap.of(
          "pred Loop[This: List] {\n"
              + "\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "\n"
              + "}", 1,
          "pred Sorted[This: List] {\n"
              + "\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "\n"
              + "}", 2,
          "pred Count[This: List,x: Int,result: Int] {\n"
              + "(RepOk[This])\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(RepOk[This])\n"
              + "}", 3,
          "pred Contains[This: List,x: Int,result: Boolean] {\n"
              + "(RepOk[This])\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(RepOk[This])\n"
              + "}", 4)),
  STUDENT_17(
      "student17",
      ImmutableMap.of(
          "pred Loop[This: List] {\n"
              + "(one n: (one ((This.header).(*link))) {\n"
              + "((n.link) = n)\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(one n: (one ((This.header).(*link))) {\n"
              + "((n.link) = n)\n"
              + "})\n"
              + "}", 1,
          "pred Sorted[This: List] {\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "}", 2)),
  STUDENT_18(
      "student18",
      ImmutableMap.of(
          "pred Loop[This: List] {\n"
              + "((no ((This.header).link)) || (one n: (one ((This.header).(*link))) {\n"
              + "((n.link) = n)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((no ((This.header).link)) || (one n: (one ((This.header).(*link))) {\n"
              + "((n.link) = n)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((no ((This.header).link)) || (one n: (one ((This.header).(*link))) {\n"
              + "((n.link) = n)\n"
              + "}))\n"
              + "|\n"
              + "(no ((This.header).link))\n"
              + "|\n"
              + "((This.header).link)", 1,
          "pred Loop[This: List] {\n"
              + "((no ((This.header).link)) || (one n: (one ((This.header).(*link))) {\n"
              + "((n.link) = n)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((no ((This.header).link)) || (one n: (one ((This.header).(*link))) {\n"
              + "((n.link) = n)\n"
              + "}))\n"
              + "}\n"
              + "|\n"
              + "((no ((This.header).link)) || (one n: (one ((This.header).(*link))) {\n"
              + "((n.link) = n)\n"
              + "}))\n"
              + "|\n"
              + "(no ((This.header).link))\n"
              + "|\n"
              + "((This.header).link)\n"
              + "|\n"
              + "link", 1,
          "pred Sorted[This: List] {\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((one (n.link)) && ((n.elem) <= ((n.link).elem)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((one (n.link)) && ((n.elem) <= ((n.link).elem)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((one (n.link)) && ((n.elem) <= ((n.link).elem)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((one (n.link)) && ((n.elem) <= ((n.link).elem)))\n"
              + "}\n"
              + "|\n"
              + "((one (n.link)) && ((n.elem) <= ((n.link).elem)))\n"
              + "|\n"
              + "(one (n.link))", 2,
          "pred Sorted[This: List] {\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((one (n.link)) && ((n.elem) <= ((n.link).elem)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((one (n.link)) && ((n.elem) <= ((n.link).elem)))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((one (n.link)) && ((n.elem) <= ((n.link).elem)))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((one (n.link)) && ((n.elem) <= ((n.link).elem)))\n"
              + "}\n"
              + "|\n"
              + "((one (n.link)) && ((n.elem) <= ((n.link).elem)))", 2,
          "pred Count[This: List,x: Int,result: Int] {\n"
              + "((RepOk[This]) && (result = (#({ n: (one Node) {\n"
              + "((n in ((This.header).(*link))) || ((n.elem) = x))\n"
              + "} }))))\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "((RepOk[This]) && (result = (#({ n: (one Node) {\n"
              + "((n in ((This.header).(*link))) || ((n.elem) = x))\n"
              + "} }))))\n"
              + "}\n"
              + "|\n"
              + "((RepOk[This]) && (result = (#({ n: (one Node) {\n"
              + "((n in ((This.header).(*link))) || ((n.elem) = x))\n"
              + "} }))))\n"
              + "|\n"
              + "(result = (#({ n: (one Node) {\n"
              + "((n in ((This.header).(*link))) || ((n.elem) = x))\n"
              + "} })))\n"
              + "|\n"
              + "(#({ n: (one Node) {\n"
              + "((n in ((This.header).(*link))) || ((n.elem) = x))\n"
              + "} }))\n"
              + "|\n"
              + "({ n: (one Node) {\n"
              + "((n in ((This.header).(*link))) || ((n.elem) = x))\n"
              + "} })\n"
              + "|\n"
              + "{\n"
              + "((n in ((This.header).(*link))) || ((n.elem) = x))\n"
              + "}\n"
              + "|\n"
              + "((n in ((This.header).(*link))) || ((n.elem) = x))", 3)),
  STUDENT_19(
      "student19",
      ImmutableMap.<String, Integer>builder().put(
          "pred Sorted[This: List] {\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "{\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "}\n"
              + "|\n"
              + "(all n: (one ((This.header).(*link))) {\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "})\n"
              + "|\n"
              + "{\n"
              + "((n.elem) <= ((n.link).elem))\n"
              + "}", 1)
          .put(
              "pred Count[This: List,x: Int,result: Int] {\n"
                  + "((RepOk[This]) && (all n: (one (((This.header).(*link)).elem)) {\n"
                  + "(x = n)\n"
                  + "}) && (result = (#x)))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((RepOk[This]) && (all n: (one (((This.header).(*link)).elem)) {\n"
                  + "(x = n)\n"
                  + "}) && (result = (#x)))\n"
                  + "}\n"
                  + "|\n"
                  + "((RepOk[This]) && (all n: (one (((This.header).(*link)).elem)) {\n"
                  + "(x = n)\n"
                  + "}) && (result = (#x)))", 2)
          .put(
              "pred Count[This: List,x: Int,result: Int] {\n"
                  + "((RepOk[This]) && (all n: (one (((This.header).(*link)).elem)) {\n"
                  + "(x = n)\n"
                  + "}) && (result = (#x)))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((RepOk[This]) && (all n: (one (((This.header).(*link)).elem)) {\n"
                  + "(x = n)\n"
                  + "}) && (result = (#x)))\n"
                  + "}\n"
                  + "|\n"
                  + "((RepOk[This]) && (all n: (one (((This.header).(*link)).elem)) {\n"
                  + "(x = n)\n"
                  + "}) && (result = (#x)))\n"
                  + "|\n"
                  + "(all n: (one (((This.header).(*link)).elem)) {\n"
                  + "(x = n)\n"
                  + "})", 2)
          .put(
              "pred Count[This: List,x: Int,result: Int] {\n"
                  + "((RepOk[This]) && (all n: (one (((This.header).(*link)).elem)) {\n"
                  + "(x = n)\n"
                  + "}) && (result = (#x)))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((RepOk[This]) && (all n: (one (((This.header).(*link)).elem)) {\n"
                  + "(x = n)\n"
                  + "}) && (result = (#x)))\n"
                  + "}\n"
                  + "|\n"
                  + "((RepOk[This]) && (all n: (one (((This.header).(*link)).elem)) {\n"
                  + "(x = n)\n"
                  + "}) && (result = (#x)))\n"
                  + "|\n"
                  + "(result = (#x))", 2)
          .put(
              "pred Contains[This: List,x: Int,result: Boolean] {\n"
                  + "((RepOk[This]) && ((some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}) || (all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "})))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((RepOk[This]) && ((some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}) || (all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "})))\n"
                  + "}\n"
                  + "|\n"
                  + "((RepOk[This]) && ((some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}) || (all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "})))\n"
                  + "|\n"
                  + "((some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}) || (all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "}))\n"
                  + "|\n"
                  + "(some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "})", 3)
          .put(
              "pred Contains[This: List,x: Int,result: Boolean] {\n"
                  + "((RepOk[This]) && ((some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}) || (all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "})))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((RepOk[This]) && ((some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}) || (all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "})))\n"
                  + "}\n"
                  + "|\n"
                  + "((RepOk[This]) && ((some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}) || (all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "})))\n"
                  + "|\n"
                  + "((some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}) || (all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "}))\n"
                  + "|\n"
                  + "(some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}\n"
                  + "|\n"
                  + "((x in (n.elem)) && (result = True))", 3)
          .put(
              "pred Contains[This: List,x: Int,result: Boolean] {\n"
                  + "((RepOk[This]) && ((some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}) || (all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "})))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((RepOk[This]) && ((some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}) || (all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "})))\n"
                  + "}\n"
                  + "|\n"
                  + "((RepOk[This]) && ((some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}) || (all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "})))\n"
                  + "|\n"
                  + "((some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}) || (all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "})", 3)
          .put(
              "pred Contains[This: List,x: Int,result: Boolean] {\n"
                  + "((RepOk[This]) && ((some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}) || (all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "})))\n"
                  + "}\n"
                  + "|\n"
                  + "{\n"
                  + "((RepOk[This]) && ((some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}) || (all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "})))\n"
                  + "}\n"
                  + "|\n"
                  + "((RepOk[This]) && ((some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}) || (all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "})))\n"
                  + "|\n"
                  + "((some n: (one ((This.header).(*link))) {\n"
                  + "((x in (n.elem)) && (result = True))\n"
                  + "}) || (all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "}))\n"
                  + "|\n"
                  + "(all n: (one ((This.header).(*link))) {\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "})\n"
                  + "|\n"
                  + "{\n"
                  + "((x !in (n.elem)) && (result = False))\n"
                  + "}\n"
                  + "|\n"
                  + "((x !in (n.elem)) && (result = False))", 3).build());

  private String modelName;
  /**
   * Specify the node path and fault ID mapping.  Node path is stored as string which point to the
   * exact faults.
   */
  private ImmutableMap<String, Integer> exactFaultIdentifiers;

  private final static String GEN_DIR = "experiments/gen/real";
  private final static String RESULT_DIR = "experiments/results/real";

  RealFaultInfo(String modelName, ImmutableMap<String, Integer> exactFaultIdentifiers) {
    this.modelName = modelName;
    this.exactFaultIdentifiers = exactFaultIdentifiers;
  }

  public String getModelPath() {
    return Paths.get(GEN_DIR, modelName, modelName + Names.DOT_ALS).toString();
  }

  public String getFltPath() {
    return Paths.get(RESULT_DIR, modelName, modelName + Names.DOT_FLT).toString();
  }

  public Map<String, Integer> getExactFaultIdentifiers() {
    return Maps.newHashMap(exactFaultIdentifiers);
  }
}
